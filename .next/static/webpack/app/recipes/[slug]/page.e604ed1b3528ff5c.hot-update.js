"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/recipes/[slug]/page",{

/***/ "(app-pages-browser)/./app/recipes/data/evaluator-optimizer.ts":
/*!*************************************************!*\
  !*** ./app/recipes/data/evaluator-optimizer.ts ***!
  \*************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   evaluatorOptimizer: function() { return /* binding */ evaluatorOptimizer; }\n/* harmony export */ });\nconst evaluatorOptimizer = {\n    title: \"Evaluator-optimizer\",\n    tag: \"Loops\",\n    description: \"The Evaluator-Optimizer workflow is an iterative process designed to progressively improve outputs through repeated evaluation and refinement. This approach is particularly useful for tasks that require high accuracy or quality.\",\n    explanation: \"The diagram illustrates a cyclical process where an initial solution is evaluated, and if it doesn't meet the criteria, it's passed to an optimizer for refinement. This cycle continues until a satisfactory solution is found or a maximum number of iterations is reached.\",\n    useCases: [\n        \"Content Refinement: Iteratively improve written content by checking tone, clarity, and engagement.\",\n        \"Code Optimization: Generate and improve code solutions by evaluating performance and best practices.\",\n        \"Data Analysis Reports: Progressively refine reports by evaluating completeness and clarity of insights.\"\n    ],\n    pythonCode: 'from typing import Dict, Any, List, Optional\\nfrom pydantic import BaseModel\\nfrom helpers import run_llm, JSON_llm\\n\\nclass EvaluationResult(BaseModel):\\n    \"\"\"Evaluation results with scores and feedback\"\"\"\\n    scores: Dict[str, float]\\n    feedback: List[str]\\n    meets_criteria: bool\\n\\nclass OptimizationResult(BaseModel):\\n    \"\"\"Optimization result with improved content\"\"\"\\n    content: str\\n    changes_made: List[str]\\n\\nasync def evaluate_content(\\n    content: str,\\n    criteria: Dict[str, str]\\n) -> EvaluationResult:\\n    \"\"\"Evaluate content against specified criteria\"\"\"\\n    \\n    EVAL_PROMPT = \"\"\"Evaluate the following content against these criteria:\\n    {criteria}\\n    \\n    For each criterion:\\n    1. Assign a score (0-10)\\n    2. Provide specific feedback\\n    3. Indicate if it meets the minimum threshold (7/10)\\n    \\n    Return as JSON with:\\n    - scores: Dict[str, float]\\n    - feedback: List[str]\\n    - meets_criteria: bool (true if all scores >= 7)\\n    \"\"\"\\n    \\n    evaluation = await JSON_llm(\\n        EVAL_PROMPT.format(\\n            criteria=\"\\\\n\".join(f\"- {k}: {v}\" for k, v in criteria.items())\\n        ) + f\"\\\\n\\\\nContent:\\\\n{content}\",\\n        EvaluationResult\\n    )\\n    \\n    return evaluation\\n\\nasync def optimize_content(\\n    content: str,\\n    evaluation: EvaluationResult\\n) -> OptimizationResult:\\n    \"\"\"Optimize content based on evaluation feedback\"\"\"\\n    \\n    OPTIMIZE_PROMPT = \"\"\"Improve the following content based on this feedback:\\n    {feedback}\\n    \\n    Return as JSON with:\\n    - content: improved version\\n    - changes_made: list of specific improvements made\\n    \"\"\"\\n    \\n    optimization = await JSON_llm(\\n        OPTIMIZE_PROMPT.format(\\n            feedback=\"\\\\n\".join(f\"- {f}\" for f in evaluation.feedback)\\n        ) + f\"\\\\n\\\\nOriginal Content:\\\\n{content}\",\\n        OptimizationResult\\n    )\\n    \\n    return optimization\\n\\nasync def evaluator_optimizer_workflow(\\n    initial_content: str,\\n    criteria: Dict[str, str],\\n    max_iterations: int = 5\\n) -> str:\\n    \"\"\"Iteratively improve content through evaluation and optimization\"\"\"\\n    \\n    content = initial_content\\n    iteration = 0\\n    \\n    while iteration < max_iterations:\\n        print(f\"\\\\nIteration {iteration + 1}\")\\n        print(\"-\" * 40)\\n        \\n        # Evaluate current content\\n        evaluation = await evaluate_content(content, criteria)\\n        \\n        # Print evaluation results\\n        print(\"\\\\nEvaluation Scores:\")\\n        for criterion, score in evaluation.scores.items():\\n            print(f\"{criterion}: {score}/10\")\\n        \\n        print(\"\\\\nFeedback:\")\\n        for feedback in evaluation.feedback:\\n            print(f\"- {feedback}\")\\n        \\n        # Check if content meets all criteria\\n        if evaluation.meets_criteria:\\n            print(\"\\\\nSuccess! All criteria met.\")\\n            break\\n        \\n        # Optimize content based on evaluation\\n        optimization = await optimize_content(content, evaluation)\\n        content = optimization.content\\n        \\n        print(\"\\\\nImprovements Made:\")\\n        for change in optimization.changes_made:\\n            print(f\"- {change}\")\\n        \\n        iteration += 1\\n    \\n    return content\\n\\n# Example usage\\nasync def main():\\n    blog_post = \"\"\"\\n    AI is changing everything. It\\'s making things faster and better. \\n    Companies are using it a lot. Some people are worried about it \\n    but it\\'s probably fine. Everyone should learn about AI because \\n    it\\'s important for the future.\\n    \"\"\"\\n    \\n    criteria = {\\n        \"clarity\": \"Ideas should be clearly explained with specific examples\",\\n        \"depth\": \"Content should provide meaningful insights and analysis\",\\n        \"engagement\": \"Writing should be engaging and maintain reader interest\",\\n        \"professionalism\": \"Tone should be professional and authoritative\",\\n        \"structure\": \"Content should be well-organized with logical flow\"\\n    }\\n    \\n    final_content = await evaluator_optimizer_workflow(blog_post, criteria)\\n    print(\"\\\\nFinal Optimized Content:\\\\n\", final_content)\\n\\nif __name__ == \"__main__\":\\n    import asyncio\\n    asyncio.run(main())',\n    typescriptCode: 'import { LLMResponse } from \\'./types\\';\\nimport { runLLM, JSONLLM } from \\'./helpers\\';\\n\\ninterface EvaluationResult {\\n  scores: Record<string, number>;\\n  feedback: string[];\\n  meets_criteria: boolean;\\n}\\n\\ninterface OptimizationResult {\\n  content: string;\\n  changes_made: string[];\\n}\\n\\nasync function evaluateContent(\\n  content: string,\\n  criteria: Record<string, string>\\n): Promise<EvaluationResult> {\\n  const EVAL_PROMPT = `Evaluate the following content against these criteria:\\n  ${Object.entries(criteria)\\n    .map(([k, v]) => `- ${k}: ${v}`)\\n    .join(\\'\\\\n\\')}\\n  \\n  For each criterion:\\n  1. Assign a score (0-10)\\n  2. Provide specific feedback\\n  3. Indicate if it meets the minimum threshold (7/10)\\n  \\n  Return as JSON with:\\n  - scores: Record<string, number>\\n  - feedback: string[]\\n  - meets_criteria: boolean (true if all scores >= 7)\\n  `;\\n\\n  return await JSONLLM<EvaluationResult>(\\n    `${EVAL_PROMPT}\\\\n\\\\nContent:\\\\n${content}`\\n  );\\n}\\n\\nasync function optimizeContent(\\n  content: string,\\n  evaluation: EvaluationResult\\n): Promise<OptimizationResult> {\\n  const OPTIMIZE_PROMPT = `Improve the following content based on this feedback:\\n  ${evaluation.feedback.map(f => `- ${f}`).join(\\'\\\\n\\')}\\n  \\n  Return as JSON with:\\n  - content: improved version\\n  - changes_made: list of specific improvements made\\n  `;\\n\\n  return await JSONLLM<OptimizationResult>(\\n    `${OPTIMIZE_PROMPT}\\\\n\\\\nOriginal Content:\\\\n${content}`\\n  );\\n}\\n\\nasync function evaluatorOptimizerWorkflow(\\n  initialContent: string,\\n  criteria: Record<string, string>,\\n  maxIterations: number = 5\\n): Promise<string> {\\n  let content = initialContent;\\n  let iteration = 0;\\n\\n  while (iteration < maxIterations) {\\n    console.log(`\\\\nIteration ${iteration + 1}`);\\n    console.log(\"-\".repeat(40));\\n\\n    // Evaluate current content\\n    const evaluation = await evaluateContent(content, criteria);\\n\\n    // Print evaluation results\\n    console.log(\"\\\\nEvaluation Scores:\");\\n    Object.entries(evaluation.scores).forEach(([criterion, score]) => {\\n      console.log(`${criterion}: ${score}/10`);\\n    });\\n\\n    console.log(\"\\\\nFeedback:\");\\n    evaluation.feedback.forEach(feedback => {\\n      console.log(`- ${feedback}`);\\n    });\\n\\n    // Check if content meets all criteria\\n    if (evaluation.meets_criteria) {\\n      console.log(\"\\\\nSuccess! All criteria met.\");\\n      break;\\n    }\\n\\n    // Optimize content based on evaluation\\n    const optimization = await optimizeContent(content, evaluation);\\n    content = optimization.content;\\n\\n    console.log(\"\\\\nImprovements Made:\");\\n    optimization.changes_made.forEach(change => {\\n      console.log(`- ${change}`);\\n    });\\n\\n    iteration++;\\n  }\\n\\n  return content;\\n}\\n\\n// Example usage\\nasync function main() {\\n  const blogPost = `\\n    AI is changing everything. It\\'s making things faster and better. \\n    Companies are using it a lot. Some people are worried about it \\n    but it\\'s probably fine. Everyone should learn about AI because \\n    it\\'s important for the future.\\n  `;\\n\\n  const criteria = {\\n    clarity: \"Ideas should be clearly explained with specific examples\",\\n    depth: \"Content should provide meaningful insights and analysis\",\\n    engagement: \"Writing should be engaging and maintain reader interest\",\\n    professionalism: \"Tone should be professional and authoritative\",\\n    structure: \"Content should be well-organized with logical flow\"\\n  };\\n\\n  const finalContent = await evaluatorOptimizerWorkflow(blogPost, criteria);\\n  console.log(\"\\\\nFinal Optimized Content:\\\\n\", finalContent);\\n}\\n\\nmain().catch(console.error);'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9yZWNpcGVzL2RhdGEvZXZhbHVhdG9yLW9wdGltaXplci50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRU8sTUFBTUEscUJBQTZCO0lBQ3hDQyxPQUFPO0lBQ1BDLEtBQUs7SUFDTEMsYUFBYTtJQUNiQyxhQUFhO0lBQ2JDLFVBQVU7UUFDUjtRQUNBO1FBQ0E7S0FDRDtJQUNEQyxZQUFhO0lBcUliQyxnQkFBaUI7QUE2SG5CLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL3JlY2lwZXMvZGF0YS9ldmFsdWF0b3Itb3B0aW1pemVyLnRzPzZmNTUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjaXBlIH0gZnJvbSAnLi9pbmRleCc7XHJcblxyXG5leHBvcnQgY29uc3QgZXZhbHVhdG9yT3B0aW1pemVyOiBSZWNpcGUgPSB7XHJcbiAgdGl0bGU6IFwiRXZhbHVhdG9yLW9wdGltaXplclwiLFxyXG4gIHRhZzogXCJMb29wc1wiLFxyXG4gIGRlc2NyaXB0aW9uOiBcIlRoZSBFdmFsdWF0b3ItT3B0aW1pemVyIHdvcmtmbG93IGlzIGFuIGl0ZXJhdGl2ZSBwcm9jZXNzIGRlc2lnbmVkIHRvIHByb2dyZXNzaXZlbHkgaW1wcm92ZSBvdXRwdXRzIHRocm91Z2ggcmVwZWF0ZWQgZXZhbHVhdGlvbiBhbmQgcmVmaW5lbWVudC4gVGhpcyBhcHByb2FjaCBpcyBwYXJ0aWN1bGFybHkgdXNlZnVsIGZvciB0YXNrcyB0aGF0IHJlcXVpcmUgaGlnaCBhY2N1cmFjeSBvciBxdWFsaXR5LlwiLFxyXG4gIGV4cGxhbmF0aW9uOiBcIlRoZSBkaWFncmFtIGlsbHVzdHJhdGVzIGEgY3ljbGljYWwgcHJvY2VzcyB3aGVyZSBhbiBpbml0aWFsIHNvbHV0aW9uIGlzIGV2YWx1YXRlZCwgYW5kIGlmIGl0IGRvZXNuJ3QgbWVldCB0aGUgY3JpdGVyaWEsIGl0J3MgcGFzc2VkIHRvIGFuIG9wdGltaXplciBmb3IgcmVmaW5lbWVudC4gVGhpcyBjeWNsZSBjb250aW51ZXMgdW50aWwgYSBzYXRpc2ZhY3Rvcnkgc29sdXRpb24gaXMgZm91bmQgb3IgYSBtYXhpbXVtIG51bWJlciBvZiBpdGVyYXRpb25zIGlzIHJlYWNoZWQuXCIsXHJcbiAgdXNlQ2FzZXM6IFtcclxuICAgIFwiQ29udGVudCBSZWZpbmVtZW50OiBJdGVyYXRpdmVseSBpbXByb3ZlIHdyaXR0ZW4gY29udGVudCBieSBjaGVja2luZyB0b25lLCBjbGFyaXR5LCBhbmQgZW5nYWdlbWVudC5cIixcclxuICAgIFwiQ29kZSBPcHRpbWl6YXRpb246IEdlbmVyYXRlIGFuZCBpbXByb3ZlIGNvZGUgc29sdXRpb25zIGJ5IGV2YWx1YXRpbmcgcGVyZm9ybWFuY2UgYW5kIGJlc3QgcHJhY3RpY2VzLlwiLFxyXG4gICAgXCJEYXRhIEFuYWx5c2lzIFJlcG9ydHM6IFByb2dyZXNzaXZlbHkgcmVmaW5lIHJlcG9ydHMgYnkgZXZhbHVhdGluZyBjb21wbGV0ZW5lc3MgYW5kIGNsYXJpdHkgb2YgaW5zaWdodHMuXCJcclxuICBdLFxyXG4gIHB5dGhvbkNvZGU6IGBmcm9tIHR5cGluZyBpbXBvcnQgRGljdCwgQW55LCBMaXN0LCBPcHRpb25hbFxyXG5mcm9tIHB5ZGFudGljIGltcG9ydCBCYXNlTW9kZWxcclxuZnJvbSBoZWxwZXJzIGltcG9ydCBydW5fbGxtLCBKU09OX2xsbVxyXG5cclxuY2xhc3MgRXZhbHVhdGlvblJlc3VsdChCYXNlTW9kZWwpOlxyXG4gICAgXCJcIlwiRXZhbHVhdGlvbiByZXN1bHRzIHdpdGggc2NvcmVzIGFuZCBmZWVkYmFja1wiXCJcIlxyXG4gICAgc2NvcmVzOiBEaWN0W3N0ciwgZmxvYXRdXHJcbiAgICBmZWVkYmFjazogTGlzdFtzdHJdXHJcbiAgICBtZWV0c19jcml0ZXJpYTogYm9vbFxyXG5cclxuY2xhc3MgT3B0aW1pemF0aW9uUmVzdWx0KEJhc2VNb2RlbCk6XHJcbiAgICBcIlwiXCJPcHRpbWl6YXRpb24gcmVzdWx0IHdpdGggaW1wcm92ZWQgY29udGVudFwiXCJcIlxyXG4gICAgY29udGVudDogc3RyXHJcbiAgICBjaGFuZ2VzX21hZGU6IExpc3Rbc3RyXVxyXG5cclxuYXN5bmMgZGVmIGV2YWx1YXRlX2NvbnRlbnQoXHJcbiAgICBjb250ZW50OiBzdHIsXHJcbiAgICBjcml0ZXJpYTogRGljdFtzdHIsIHN0cl1cclxuKSAtPiBFdmFsdWF0aW9uUmVzdWx0OlxyXG4gICAgXCJcIlwiRXZhbHVhdGUgY29udGVudCBhZ2FpbnN0IHNwZWNpZmllZCBjcml0ZXJpYVwiXCJcIlxyXG4gICAgXHJcbiAgICBFVkFMX1BST01QVCA9IFwiXCJcIkV2YWx1YXRlIHRoZSBmb2xsb3dpbmcgY29udGVudCBhZ2FpbnN0IHRoZXNlIGNyaXRlcmlhOlxyXG4gICAge2NyaXRlcmlhfVxyXG4gICAgXHJcbiAgICBGb3IgZWFjaCBjcml0ZXJpb246XHJcbiAgICAxLiBBc3NpZ24gYSBzY29yZSAoMC0xMClcclxuICAgIDIuIFByb3ZpZGUgc3BlY2lmaWMgZmVlZGJhY2tcclxuICAgIDMuIEluZGljYXRlIGlmIGl0IG1lZXRzIHRoZSBtaW5pbXVtIHRocmVzaG9sZCAoNy8xMClcclxuICAgIFxyXG4gICAgUmV0dXJuIGFzIEpTT04gd2l0aDpcclxuICAgIC0gc2NvcmVzOiBEaWN0W3N0ciwgZmxvYXRdXHJcbiAgICAtIGZlZWRiYWNrOiBMaXN0W3N0cl1cclxuICAgIC0gbWVldHNfY3JpdGVyaWE6IGJvb2wgKHRydWUgaWYgYWxsIHNjb3JlcyA+PSA3KVxyXG4gICAgXCJcIlwiXHJcbiAgICBcclxuICAgIGV2YWx1YXRpb24gPSBhd2FpdCBKU09OX2xsbShcclxuICAgICAgICBFVkFMX1BST01QVC5mb3JtYXQoXHJcbiAgICAgICAgICAgIGNyaXRlcmlhPVwiXFxcXG5cIi5qb2luKGZcIi0ge2t9OiB7dn1cIiBmb3IgaywgdiBpbiBjcml0ZXJpYS5pdGVtcygpKVxyXG4gICAgICAgICkgKyBmXCJcXFxcblxcXFxuQ29udGVudDpcXFxcbntjb250ZW50fVwiLFxyXG4gICAgICAgIEV2YWx1YXRpb25SZXN1bHRcclxuICAgIClcclxuICAgIFxyXG4gICAgcmV0dXJuIGV2YWx1YXRpb25cclxuXHJcbmFzeW5jIGRlZiBvcHRpbWl6ZV9jb250ZW50KFxyXG4gICAgY29udGVudDogc3RyLFxyXG4gICAgZXZhbHVhdGlvbjogRXZhbHVhdGlvblJlc3VsdFxyXG4pIC0+IE9wdGltaXphdGlvblJlc3VsdDpcclxuICAgIFwiXCJcIk9wdGltaXplIGNvbnRlbnQgYmFzZWQgb24gZXZhbHVhdGlvbiBmZWVkYmFja1wiXCJcIlxyXG4gICAgXHJcbiAgICBPUFRJTUlaRV9QUk9NUFQgPSBcIlwiXCJJbXByb3ZlIHRoZSBmb2xsb3dpbmcgY29udGVudCBiYXNlZCBvbiB0aGlzIGZlZWRiYWNrOlxyXG4gICAge2ZlZWRiYWNrfVxyXG4gICAgXHJcbiAgICBSZXR1cm4gYXMgSlNPTiB3aXRoOlxyXG4gICAgLSBjb250ZW50OiBpbXByb3ZlZCB2ZXJzaW9uXHJcbiAgICAtIGNoYW5nZXNfbWFkZTogbGlzdCBvZiBzcGVjaWZpYyBpbXByb3ZlbWVudHMgbWFkZVxyXG4gICAgXCJcIlwiXHJcbiAgICBcclxuICAgIG9wdGltaXphdGlvbiA9IGF3YWl0IEpTT05fbGxtKFxyXG4gICAgICAgIE9QVElNSVpFX1BST01QVC5mb3JtYXQoXHJcbiAgICAgICAgICAgIGZlZWRiYWNrPVwiXFxcXG5cIi5qb2luKGZcIi0ge2Z9XCIgZm9yIGYgaW4gZXZhbHVhdGlvbi5mZWVkYmFjaylcclxuICAgICAgICApICsgZlwiXFxcXG5cXFxcbk9yaWdpbmFsIENvbnRlbnQ6XFxcXG57Y29udGVudH1cIixcclxuICAgICAgICBPcHRpbWl6YXRpb25SZXN1bHRcclxuICAgIClcclxuICAgIFxyXG4gICAgcmV0dXJuIG9wdGltaXphdGlvblxyXG5cclxuYXN5bmMgZGVmIGV2YWx1YXRvcl9vcHRpbWl6ZXJfd29ya2Zsb3coXHJcbiAgICBpbml0aWFsX2NvbnRlbnQ6IHN0cixcclxuICAgIGNyaXRlcmlhOiBEaWN0W3N0ciwgc3RyXSxcclxuICAgIG1heF9pdGVyYXRpb25zOiBpbnQgPSA1XHJcbikgLT4gc3RyOlxyXG4gICAgXCJcIlwiSXRlcmF0aXZlbHkgaW1wcm92ZSBjb250ZW50IHRocm91Z2ggZXZhbHVhdGlvbiBhbmQgb3B0aW1pemF0aW9uXCJcIlwiXHJcbiAgICBcclxuICAgIGNvbnRlbnQgPSBpbml0aWFsX2NvbnRlbnRcclxuICAgIGl0ZXJhdGlvbiA9IDBcclxuICAgIFxyXG4gICAgd2hpbGUgaXRlcmF0aW9uIDwgbWF4X2l0ZXJhdGlvbnM6XHJcbiAgICAgICAgcHJpbnQoZlwiXFxcXG5JdGVyYXRpb24ge2l0ZXJhdGlvbiArIDF9XCIpXHJcbiAgICAgICAgcHJpbnQoXCItXCIgKiA0MClcclxuICAgICAgICBcclxuICAgICAgICAjIEV2YWx1YXRlIGN1cnJlbnQgY29udGVudFxyXG4gICAgICAgIGV2YWx1YXRpb24gPSBhd2FpdCBldmFsdWF0ZV9jb250ZW50KGNvbnRlbnQsIGNyaXRlcmlhKVxyXG4gICAgICAgIFxyXG4gICAgICAgICMgUHJpbnQgZXZhbHVhdGlvbiByZXN1bHRzXHJcbiAgICAgICAgcHJpbnQoXCJcXFxcbkV2YWx1YXRpb24gU2NvcmVzOlwiKVxyXG4gICAgICAgIGZvciBjcml0ZXJpb24sIHNjb3JlIGluIGV2YWx1YXRpb24uc2NvcmVzLml0ZW1zKCk6XHJcbiAgICAgICAgICAgIHByaW50KGZcIntjcml0ZXJpb259OiB7c2NvcmV9LzEwXCIpXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJpbnQoXCJcXFxcbkZlZWRiYWNrOlwiKVxyXG4gICAgICAgIGZvciBmZWVkYmFjayBpbiBldmFsdWF0aW9uLmZlZWRiYWNrOlxyXG4gICAgICAgICAgICBwcmludChmXCItIHtmZWVkYmFja31cIilcclxuICAgICAgICBcclxuICAgICAgICAjIENoZWNrIGlmIGNvbnRlbnQgbWVldHMgYWxsIGNyaXRlcmlhXHJcbiAgICAgICAgaWYgZXZhbHVhdGlvbi5tZWV0c19jcml0ZXJpYTpcclxuICAgICAgICAgICAgcHJpbnQoXCJcXFxcblN1Y2Nlc3MhIEFsbCBjcml0ZXJpYSBtZXQuXCIpXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgXHJcbiAgICAgICAgIyBPcHRpbWl6ZSBjb250ZW50IGJhc2VkIG9uIGV2YWx1YXRpb25cclxuICAgICAgICBvcHRpbWl6YXRpb24gPSBhd2FpdCBvcHRpbWl6ZV9jb250ZW50KGNvbnRlbnQsIGV2YWx1YXRpb24pXHJcbiAgICAgICAgY29udGVudCA9IG9wdGltaXphdGlvbi5jb250ZW50XHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJpbnQoXCJcXFxcbkltcHJvdmVtZW50cyBNYWRlOlwiKVxyXG4gICAgICAgIGZvciBjaGFuZ2UgaW4gb3B0aW1pemF0aW9uLmNoYW5nZXNfbWFkZTpcclxuICAgICAgICAgICAgcHJpbnQoZlwiLSB7Y2hhbmdlfVwiKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGl0ZXJhdGlvbiArPSAxXHJcbiAgICBcclxuICAgIHJldHVybiBjb250ZW50XHJcblxyXG4jIEV4YW1wbGUgdXNhZ2VcclxuYXN5bmMgZGVmIG1haW4oKTpcclxuICAgIGJsb2dfcG9zdCA9IFwiXCJcIlxyXG4gICAgQUkgaXMgY2hhbmdpbmcgZXZlcnl0aGluZy4gSXQncyBtYWtpbmcgdGhpbmdzIGZhc3RlciBhbmQgYmV0dGVyLiBcclxuICAgIENvbXBhbmllcyBhcmUgdXNpbmcgaXQgYSBsb3QuIFNvbWUgcGVvcGxlIGFyZSB3b3JyaWVkIGFib3V0IGl0IFxyXG4gICAgYnV0IGl0J3MgcHJvYmFibHkgZmluZS4gRXZlcnlvbmUgc2hvdWxkIGxlYXJuIGFib3V0IEFJIGJlY2F1c2UgXHJcbiAgICBpdCdzIGltcG9ydGFudCBmb3IgdGhlIGZ1dHVyZS5cclxuICAgIFwiXCJcIlxyXG4gICAgXHJcbiAgICBjcml0ZXJpYSA9IHtcclxuICAgICAgICBcImNsYXJpdHlcIjogXCJJZGVhcyBzaG91bGQgYmUgY2xlYXJseSBleHBsYWluZWQgd2l0aCBzcGVjaWZpYyBleGFtcGxlc1wiLFxyXG4gICAgICAgIFwiZGVwdGhcIjogXCJDb250ZW50IHNob3VsZCBwcm92aWRlIG1lYW5pbmdmdWwgaW5zaWdodHMgYW5kIGFuYWx5c2lzXCIsXHJcbiAgICAgICAgXCJlbmdhZ2VtZW50XCI6IFwiV3JpdGluZyBzaG91bGQgYmUgZW5nYWdpbmcgYW5kIG1haW50YWluIHJlYWRlciBpbnRlcmVzdFwiLFxyXG4gICAgICAgIFwicHJvZmVzc2lvbmFsaXNtXCI6IFwiVG9uZSBzaG91bGQgYmUgcHJvZmVzc2lvbmFsIGFuZCBhdXRob3JpdGF0aXZlXCIsXHJcbiAgICAgICAgXCJzdHJ1Y3R1cmVcIjogXCJDb250ZW50IHNob3VsZCBiZSB3ZWxsLW9yZ2FuaXplZCB3aXRoIGxvZ2ljYWwgZmxvd1wiXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGZpbmFsX2NvbnRlbnQgPSBhd2FpdCBldmFsdWF0b3Jfb3B0aW1pemVyX3dvcmtmbG93KGJsb2dfcG9zdCwgY3JpdGVyaWEpXHJcbiAgICBwcmludChcIlxcXFxuRmluYWwgT3B0aW1pemVkIENvbnRlbnQ6XFxcXG5cIiwgZmluYWxfY29udGVudClcclxuXHJcbmlmIF9fbmFtZV9fID09IFwiX19tYWluX19cIjpcclxuICAgIGltcG9ydCBhc3luY2lvXHJcbiAgICBhc3luY2lvLnJ1bihtYWluKCkpYCxcclxuICB0eXBlc2NyaXB0Q29kZTogYGltcG9ydCB7IExMTVJlc3BvbnNlIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IHJ1bkxMTSwgSlNPTkxMTSB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG5pbnRlcmZhY2UgRXZhbHVhdGlvblJlc3VsdCB7XHJcbiAgc2NvcmVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xyXG4gIGZlZWRiYWNrOiBzdHJpbmdbXTtcclxuICBtZWV0c19jcml0ZXJpYTogYm9vbGVhbjtcclxufVxyXG5cclxuaW50ZXJmYWNlIE9wdGltaXphdGlvblJlc3VsdCB7XHJcbiAgY29udGVudDogc3RyaW5nO1xyXG4gIGNoYW5nZXNfbWFkZTogc3RyaW5nW107XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlQ29udGVudChcclxuICBjb250ZW50OiBzdHJpbmcsXHJcbiAgY3JpdGVyaWE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz5cclxuKTogUHJvbWlzZTxFdmFsdWF0aW9uUmVzdWx0PiB7XHJcbiAgY29uc3QgRVZBTF9QUk9NUFQgPSBcXGBFdmFsdWF0ZSB0aGUgZm9sbG93aW5nIGNvbnRlbnQgYWdhaW5zdCB0aGVzZSBjcml0ZXJpYTpcclxuICBcXCR7T2JqZWN0LmVudHJpZXMoY3JpdGVyaWEpXHJcbiAgICAubWFwKChbaywgdl0pID0+IFxcYC0gXFwke2t9OiBcXCR7dn1cXGApXHJcbiAgICAuam9pbignXFxcXG4nKX1cclxuICBcclxuICBGb3IgZWFjaCBjcml0ZXJpb246XHJcbiAgMS4gQXNzaWduIGEgc2NvcmUgKDAtMTApXHJcbiAgMi4gUHJvdmlkZSBzcGVjaWZpYyBmZWVkYmFja1xyXG4gIDMuIEluZGljYXRlIGlmIGl0IG1lZXRzIHRoZSBtaW5pbXVtIHRocmVzaG9sZCAoNy8xMClcclxuICBcclxuICBSZXR1cm4gYXMgSlNPTiB3aXRoOlxyXG4gIC0gc2NvcmVzOiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+XHJcbiAgLSBmZWVkYmFjazogc3RyaW5nW11cclxuICAtIG1lZXRzX2NyaXRlcmlhOiBib29sZWFuICh0cnVlIGlmIGFsbCBzY29yZXMgPj0gNylcclxuICBcXGA7XHJcblxyXG4gIHJldHVybiBhd2FpdCBKU09OTExNPEV2YWx1YXRpb25SZXN1bHQ+KFxyXG4gICAgXFxgXFwke0VWQUxfUFJPTVBUfVxcXFxuXFxcXG5Db250ZW50OlxcXFxuXFwke2NvbnRlbnR9XFxgXHJcbiAgKTtcclxufVxyXG5cclxuYXN5bmMgZnVuY3Rpb24gb3B0aW1pemVDb250ZW50KFxyXG4gIGNvbnRlbnQ6IHN0cmluZyxcclxuICBldmFsdWF0aW9uOiBFdmFsdWF0aW9uUmVzdWx0XHJcbik6IFByb21pc2U8T3B0aW1pemF0aW9uUmVzdWx0PiB7XHJcbiAgY29uc3QgT1BUSU1JWkVfUFJPTVBUID0gXFxgSW1wcm92ZSB0aGUgZm9sbG93aW5nIGNvbnRlbnQgYmFzZWQgb24gdGhpcyBmZWVkYmFjazpcclxuICBcXCR7ZXZhbHVhdGlvbi5mZWVkYmFjay5tYXAoZiA9PiBcXGAtIFxcJHtmfVxcYCkuam9pbignXFxcXG4nKX1cclxuICBcclxuICBSZXR1cm4gYXMgSlNPTiB3aXRoOlxyXG4gIC0gY29udGVudDogaW1wcm92ZWQgdmVyc2lvblxyXG4gIC0gY2hhbmdlc19tYWRlOiBsaXN0IG9mIHNwZWNpZmljIGltcHJvdmVtZW50cyBtYWRlXHJcbiAgXFxgO1xyXG5cclxuICByZXR1cm4gYXdhaXQgSlNPTkxMTTxPcHRpbWl6YXRpb25SZXN1bHQ+KFxyXG4gICAgXFxgXFwke09QVElNSVpFX1BST01QVH1cXFxcblxcXFxuT3JpZ2luYWwgQ29udGVudDpcXFxcblxcJHtjb250ZW50fVxcYFxyXG4gICk7XHJcbn1cclxuXHJcbmFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRvck9wdGltaXplcldvcmtmbG93KFxyXG4gIGluaXRpYWxDb250ZW50OiBzdHJpbmcsXHJcbiAgY3JpdGVyaWE6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4sXHJcbiAgbWF4SXRlcmF0aW9uczogbnVtYmVyID0gNVxyXG4pOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gIGxldCBjb250ZW50ID0gaW5pdGlhbENvbnRlbnQ7XHJcbiAgbGV0IGl0ZXJhdGlvbiA9IDA7XHJcblxyXG4gIHdoaWxlIChpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XHJcbiAgICBjb25zb2xlLmxvZyhcXGBcXFxcbkl0ZXJhdGlvbiBcXCR7aXRlcmF0aW9uICsgMX1cXGApO1xyXG4gICAgY29uc29sZS5sb2coXCItXCIucmVwZWF0KDQwKSk7XHJcblxyXG4gICAgLy8gRXZhbHVhdGUgY3VycmVudCBjb250ZW50XHJcbiAgICBjb25zdCBldmFsdWF0aW9uID0gYXdhaXQgZXZhbHVhdGVDb250ZW50KGNvbnRlbnQsIGNyaXRlcmlhKTtcclxuXHJcbiAgICAvLyBQcmludCBldmFsdWF0aW9uIHJlc3VsdHNcclxuICAgIGNvbnNvbGUubG9nKFwiXFxcXG5FdmFsdWF0aW9uIFNjb3JlczpcIik7XHJcbiAgICBPYmplY3QuZW50cmllcyhldmFsdWF0aW9uLnNjb3JlcykuZm9yRWFjaCgoW2NyaXRlcmlvbiwgc2NvcmVdKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxcYFxcJHtjcml0ZXJpb259OiBcXCR7c2NvcmV9LzEwXFxgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnNvbGUubG9nKFwiXFxcXG5GZWVkYmFjazpcIik7XHJcbiAgICBldmFsdWF0aW9uLmZlZWRiYWNrLmZvckVhY2goZmVlZGJhY2sgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhcXGAtIFxcJHtmZWVkYmFja31cXGApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgY29udGVudCBtZWV0cyBhbGwgY3JpdGVyaWFcclxuICAgIGlmIChldmFsdWF0aW9uLm1lZXRzX2NyaXRlcmlhKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFwiXFxcXG5TdWNjZXNzISBBbGwgY3JpdGVyaWEgbWV0LlwiKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT3B0aW1pemUgY29udGVudCBiYXNlZCBvbiBldmFsdWF0aW9uXHJcbiAgICBjb25zdCBvcHRpbWl6YXRpb24gPSBhd2FpdCBvcHRpbWl6ZUNvbnRlbnQoY29udGVudCwgZXZhbHVhdGlvbik7XHJcbiAgICBjb250ZW50ID0gb3B0aW1pemF0aW9uLmNvbnRlbnQ7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJcXFxcbkltcHJvdmVtZW50cyBNYWRlOlwiKTtcclxuICAgIG9wdGltaXphdGlvbi5jaGFuZ2VzX21hZGUuZm9yRWFjaChjaGFuZ2UgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZyhcXGAtIFxcJHtjaGFuZ2V9XFxgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGl0ZXJhdGlvbisrO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIGNvbnRlbnQ7XHJcbn1cclxuXHJcbi8vIEV4YW1wbGUgdXNhZ2VcclxuYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcclxuICBjb25zdCBibG9nUG9zdCA9IFxcYFxyXG4gICAgQUkgaXMgY2hhbmdpbmcgZXZlcnl0aGluZy4gSXQncyBtYWtpbmcgdGhpbmdzIGZhc3RlciBhbmQgYmV0dGVyLiBcclxuICAgIENvbXBhbmllcyBhcmUgdXNpbmcgaXQgYSBsb3QuIFNvbWUgcGVvcGxlIGFyZSB3b3JyaWVkIGFib3V0IGl0IFxyXG4gICAgYnV0IGl0J3MgcHJvYmFibHkgZmluZS4gRXZlcnlvbmUgc2hvdWxkIGxlYXJuIGFib3V0IEFJIGJlY2F1c2UgXHJcbiAgICBpdCdzIGltcG9ydGFudCBmb3IgdGhlIGZ1dHVyZS5cclxuICBcXGA7XHJcblxyXG4gIGNvbnN0IGNyaXRlcmlhID0ge1xyXG4gICAgY2xhcml0eTogXCJJZGVhcyBzaG91bGQgYmUgY2xlYXJseSBleHBsYWluZWQgd2l0aCBzcGVjaWZpYyBleGFtcGxlc1wiLFxyXG4gICAgZGVwdGg6IFwiQ29udGVudCBzaG91bGQgcHJvdmlkZSBtZWFuaW5nZnVsIGluc2lnaHRzIGFuZCBhbmFseXNpc1wiLFxyXG4gICAgZW5nYWdlbWVudDogXCJXcml0aW5nIHNob3VsZCBiZSBlbmdhZ2luZyBhbmQgbWFpbnRhaW4gcmVhZGVyIGludGVyZXN0XCIsXHJcbiAgICBwcm9mZXNzaW9uYWxpc206IFwiVG9uZSBzaG91bGQgYmUgcHJvZmVzc2lvbmFsIGFuZCBhdXRob3JpdGF0aXZlXCIsXHJcbiAgICBzdHJ1Y3R1cmU6IFwiQ29udGVudCBzaG91bGQgYmUgd2VsbC1vcmdhbml6ZWQgd2l0aCBsb2dpY2FsIGZsb3dcIlxyXG4gIH07XHJcblxyXG4gIGNvbnN0IGZpbmFsQ29udGVudCA9IGF3YWl0IGV2YWx1YXRvck9wdGltaXplcldvcmtmbG93KGJsb2dQb3N0LCBjcml0ZXJpYSk7XHJcbiAgY29uc29sZS5sb2coXCJcXFxcbkZpbmFsIE9wdGltaXplZCBDb250ZW50OlxcXFxuXCIsIGZpbmFsQ29udGVudCk7XHJcbn1cclxuXHJcbm1haW4oKS5jYXRjaChjb25zb2xlLmVycm9yKTtgXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJldmFsdWF0b3JPcHRpbWl6ZXIiLCJ0aXRsZSIsInRhZyIsImRlc2NyaXB0aW9uIiwiZXhwbGFuYXRpb24iLCJ1c2VDYXNlcyIsInB5dGhvbkNvZGUiLCJ0eXBlc2NyaXB0Q29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/recipes/data/evaluator-optimizer.ts\n"));

/***/ })

});