"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/recipes/[slug]/page",{

/***/ "(app-pages-browser)/./app/recipes/data/coding-agent.ts":
/*!******************************************!*\
  !*** ./app/recipes/data/coding-agent.ts ***!
  \******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   codingAgent: function() { return /* binding */ codingAgent; }\n/* harmony export */ });\nconst codingAgent = {\n    title: \"Coding Agent\",\n    tag: \"Agent\",\n    description: \"A sophisticated workflow for AI-powered code generation that implements a robust process of task clarification, code writing, and test-driven development.\",\n    explanation: \"The diagram illustrates a comprehensive coding agent workflow with two main loops. The first loop ('Until tasks clear') handles task clarification between the human and LLM through the interface. The second loop ('Until tests pass') manages the code generation and testing process, where the LLM interacts with the environment to write, test, and refine code until it meets the specified requirements.\",\n    useCases: [\n        \"Automated Code Generation: Generate code based on natural language descriptions with built-in testing and validation.\",\n        \"Code Refactoring: Analyze existing code and suggest improvements while maintaining functionality.\",\n        \"Test-Driven Development: Generate test cases and implementation code iteratively.\"\n    ],\n    pythonCode: 'from typing import List, Dict, Any, Optional\\nfrom pydantic import BaseModel\\nfrom helpers import run_llm, JSON_llm, execute_command\\n\\nclass Requirement(BaseModel):\\n    \"\"\"Represents a clarified requirement\"\"\"\\n    description: str\\n    acceptance_criteria: List[str]\\n    test_cases: List[Dict[str, Any]]\\n\\nclass TestResult(BaseModel):\\n    \"\"\"Represents the result of running tests\"\"\"\\n    passed: bool\\n    failed_tests: List[str]\\n    error_messages: List[str]\\n    coverage: float\\n\\nclass CodingAgent:\\n    def __init__(self):\\n        self.requirements: List[Requirement] = []\\n        self.current_code: str = \"\"\\n        self.test_code: str = \"\"\\n        \\n    async def clarify_requirements(self, task_description: str) -> List[Requirement]:\\n        \"\"\"Clarify requirements through interaction with LLM\"\"\"\\n        CLARIFICATION_PROMPT = \"\"\"Analyze this coding task and break it down into clear requirements.\\n        For each requirement:\\n        1. Provide a clear description\\n        2. List specific acceptance criteria\\n        3. Define test cases with inputs and expected outputs\\n        \\n        Task: {task}\\n        \\n        Return as JSON array of requirements.\"\"\"\\n        \\n        self.requirements = await JSON_llm(\\n            CLARIFICATION_PROMPT.format(task=task_description),\\n            List[Requirement]\\n        )\\n        \\n        return self.requirements\\n    \\n    async def generate_test_code(self) -> str:\\n        \"\"\"Generate test code based on requirements\"\"\"\\n        TEST_PROMPT = \"\"\"Generate pytest test code for these requirements:\\n        {requirements}\\n        \\n        Include:\\n        1. Test cases for each requirement\\n        2. Edge cases and error conditions\\n        3. Proper test organization and setup\\n        \\n        Return only the test code.\"\"\"\\n        \\n        self.test_code = await run_llm(\\n            TEST_PROMPT.format(requirements=self.requirements)\\n        )\\n        \\n        return self.test_code\\n    \\n    async def generate_implementation(self) -> str:\\n        \"\"\"Generate implementation code based on requirements and tests\"\"\"\\n        IMPLEMENTATION_PROMPT = \"\"\"Generate implementation code that satisfies these requirements and passes these tests:\\n        \\n        Requirements:\\n        {requirements}\\n        \\n        Test Code:\\n        {test_code}\\n        \\n        Follow these guidelines:\\n        1. Write clean, well-documented code\\n        2. Include type hints\\n        3. Handle edge cases\\n        4. Follow PEP 8 style guide\\n        \\n        Return only the implementation code.\"\"\"\\n        \\n        self.current_code = await run_llm(\\n            IMPLEMENTATION_PROMPT.format(\\n                requirements=self.requirements,\\n                test_code=self.test_code\\n            )\\n        )\\n        \\n        return self.current_code\\n    \\n    async def run_tests(self) -> TestResult:\\n        \"\"\"Run tests and return results\"\"\"\\n        try:\\n            # Save code to temporary files\\n            with open(\"temp_implementation.py\", \"w\") as f:\\n                f.write(self.current_code)\\n            with open(\"temp_test.py\", \"w\") as f:\\n                f.write(self.test_code)\\n            \\n            # Run pytest with coverage\\n            result = await execute_command(\\n                \"pytest temp_test.py --cov=temp_implementation -v\"\\n            )\\n            \\n            # Parse test results\\n            return TestResult(\\n                passed=result.returncode == 0,\\n                failed_tests=self._parse_failed_tests(result.output),\\n                error_messages=self._parse_error_messages(result.output),\\n                coverage=self._parse_coverage(result.output)\\n            )\\n        finally:\\n            # Cleanup temporary files\\n            await execute_command(\"rm temp_implementation.py temp_test.py\")\\n    \\n    async def fix_issues(self, test_result: TestResult) -> str:\\n        \"\"\"Fix issues based on test results\"\"\"\\n        FIX_PROMPT = \"\"\"Fix the following issues in the code:\\n        \\n        Current Code:\\n        {code}\\n        \\n        Test Results:\\n        Failed Tests: {failed_tests}\\n        Error Messages: {errors}\\n        \\n        Return the fixed implementation code.\"\"\"\\n        \\n        self.current_code = await run_llm(\\n            FIX_PROMPT.format(\\n                code=self.current_code,\\n                failed_tests=test_result.failed_tests,\\n                errors=test_result.error_messages\\n            )\\n        )\\n        \\n        return self.current_code\\n    \\n    async def process_task(self, task_description: str, max_iterations: int = 5) -> str:\\n        \"\"\"Process a coding task from start to finish\"\"\"\\n        print(\"1. Clarifying Requirements...\")\\n        requirements = await self.clarify_requirements(task_description)\\n        for i, req in enumerate(requirements, 1):\\n            print(f\"\\\\nRequirement {i}:\")\\n            print(f\"Description: {req.description}\")\\n            print(\"Acceptance Criteria:\")\\n            for ac in req.acceptance_criteria:\\n                print(f\"- {ac}\")\\n        \\n        print(\"\\\\n2. Generating Tests...\")\\n        test_code = await self.generate_test_code()\\n        print(\"Test code generated.\")\\n        \\n        print(\"\\\\n3. Implementing Solution...\")\\n        implementation = await self.generate_implementation()\\n        print(\"Initial implementation complete.\")\\n        \\n        iteration = 0\\n        while iteration < max_iterations:\\n            print(f\"\\\\n4. Running Tests (Iteration {iteration + 1})...\")\\n            test_result = await self.run_tests()\\n            \\n            print(f\"Tests Passed: {test_result.passed}\")\\n            print(f\"Coverage: {test_result.coverage}%\")\\n            \\n            if test_result.passed and test_result.coverage >= 90:\\n                print(\"\\\\nAll tests passed with good coverage!\")\\n                break\\n            \\n            print(\"\\\\n5. Fixing Issues...\")\\n            await self.fix_issues(test_result)\\n            iteration += 1\\n        \\n        return self.current_code\\n\\n# Example usage\\nasync def main():\\n    task = \"\"\"\\n    Create a function that processes a list of financial transactions.\\n    Requirements:\\n    1. Calculate total amount, average transaction size\\n    2. Identify outliers (transactions > 2 standard deviations from mean)\\n    3. Group transactions by category\\n    4. Handle invalid inputs appropriately\\n    \"\"\"\\n    \\n    agent = CodingAgent()\\n    final_code = await agent.process_task(task)\\n    print(\"\\\\nFinal Implementation:\\\\n\", final_code)\\n\\nif __name__ == \"__main__\":\\n    import asyncio\\n    asyncio.run(main())',\n    typescriptCode: 'import { LLMResponse } from \\'./types\\';\\nimport { runLLM, JSONLLM, executeCommand } from \\'./helpers\\';\\n\\ninterface Requirement {\\n  description: string;\\n  acceptance_criteria: string[];\\n  test_cases: Array<Record<string, any>>;\\n}\\n\\ninterface TestResult {\\n  passed: boolean;\\n  failed_tests: string[];\\n  error_messages: string[];\\n  coverage: number;\\n}\\n\\nclass CodingAgent {\\n  private requirements: Requirement[] = [];\\n  private currentCode: string = \"\";\\n  private testCode: string = \"\";\\n\\n  async clarifyRequirements(taskDescription: string): Promise<Requirement[]> {\\n    const CLARIFICATION_PROMPT = `Analyze this coding task and break it down into clear requirements.\\n    For each requirement:\\n    1. Provide a clear description\\n    2. List specific acceptance criteria\\n    3. Define test cases with inputs and expected outputs\\n    \\n    Task: ${taskDescription}\\n    \\n    Return as JSON array of requirements.`;\\n\\n    this.requirements = await JSONLLM<Requirement[]>(CLARIFICATION_PROMPT);\\n    return this.requirements;\\n  }\\n\\n  async generateTestCode(): Promise<string> {\\n    const TEST_PROMPT = `Generate Jest test code for these requirements:\\n    ${JSON.stringify(this.requirements, null, 2)}\\n    \\n    Include:\\n    1. Test cases for each requirement\\n    2. Edge cases and error conditions\\n    3. Proper test organization and setup\\n    \\n    Return only the test code.`;\\n\\n    this.testCode = await runLLM(TEST_PROMPT);\\n    return this.testCode;\\n  }\\n\\n  async generateImplementation(): Promise<string> {\\n    const IMPLEMENTATION_PROMPT = `Generate implementation code that satisfies these requirements and passes these tests:\\n    \\n    Requirements:\\n    ${JSON.stringify(this.requirements, null, 2)}\\n    \\n    Test Code:\\n    ${this.testCode}\\n    \\n    Follow these guidelines:\\n    1. Write clean, well-documented code\\n    2. Include TypeScript types\\n    3. Handle edge cases\\n    4. Follow standard style guide\\n    \\n    Return only the implementation code.`;\\n\\n    this.currentCode = await runLLM(IMPLEMENTATION_PROMPT);\\n    return this.currentCode;\\n  }\\n\\n  async runTests(): Promise<TestResult> {\\n    try {\\n      // Save code to temporary files\\n      await executeCommand(`\\n        echo \\'${this.currentCode}\\' > temp_implementation.ts\\n        echo \\'${this.testCode}\\' > temp_test.ts\\n      `);\\n\\n      // Run Jest with coverage\\n      const result = await executeCommand(\\n        \"jest temp_test.ts --coverage --json\"\\n      );\\n\\n      // Parse test results from JSON output\\n      const testResults = JSON.parse(result.output);\\n\\n      return {\\n        passed: testResults.success,\\n        failed_tests: this.parseFailedTests(testResults),\\n        error_messages: this.parseErrorMessages(testResults),\\n        coverage: this.parseCoverage(testResults)\\n      };\\n    } finally {\\n      // Cleanup temporary files\\n      await executeCommand(\"rm temp_implementation.ts temp_test.ts\");\\n    }\\n  }\\n\\n  async fixIssues(testResult: TestResult): Promise<string> {\\n    const FIX_PROMPT = `Fix the following issues in the code:\\n    \\n    Current Code:\\n    ${this.currentCode}\\n    \\n    Test Results:\\n    Failed Tests: ${JSON.stringify(testResult.failed_tests)}\\n    Error Messages: ${JSON.stringify(testResult.error_messages)}\\n    \\n    Return the fixed implementation code.`;\\n\\n    this.currentCode = await runLLM(FIX_PROMPT);\\n    return this.currentCode;\\n  }\\n\\n  async processTask(\\n    taskDescription: string,\\n    maxIterations: number = 5\\n  ): Promise<string> {\\n    console.log(\"1. Clarifying Requirements...\");\\n    const requirements = await this.clarifyRequirements(taskDescription);\\n    requirements.forEach((req, i) => {\\n      console.log(`\\\\nRequirement ${i + 1}:`);\\n      console.log(`Description: ${req.description}`);\\n      console.log(\"Acceptance Criteria:\");\\n      req.acceptance_criteria.forEach(ac => console.log(`- ${ac}`));\\n    });\\n\\n    console.log(\"\\\\n2. Generating Tests...\");\\n    await this.generateTestCode();\\n    console.log(\"Test code generated.\");\\n\\n    console.log(\"\\\\n3. Implementing Solution...\");\\n    await this.generateImplementation();\\n    console.log(\"Initial implementation complete.\");\\n\\n    let iteration = 0;\\n    while (iteration < maxIterations) {\\n      console.log(`\\\\n4. Running Tests (Iteration ${iteration + 1})...`);\\n      const testResult = await this.runTests();\\n\\n      console.log(`Tests Passed: ${testResult.passed}`);\\n      console.log(`Coverage: ${testResult.coverage}%`);\\n\\n      if (testResult.passed && testResult.coverage >= 90) {\\n        console.log(\"\\\\nAll tests passed with good coverage!\");\\n        break;\\n      }\\n\\n      console.log(\"\\\\n5. Fixing Issues...\");\\n      await this.fixIssues(testResult);\\n      iteration++;\\n    }\\n\\n    return this.currentCode;\\n  }\\n\\n  private parseFailedTests(testResults: any): string[] {\\n    // Implementation of test results parsing\\n    return [];\\n  }\\n\\n  private parseErrorMessages(testResults: any): string[] {\\n    // Implementation of error message parsing\\n    return [];\\n  }\\n\\n  private parseCoverage(testResults: any): number {\\n    // Implementation of coverage parsing\\n    return 0;\\n  }\\n}\\n\\n// Example usage\\nasync function main() {\\n  const task = `\\n    Create a function that processes a list of financial transactions.\\n    Requirements:\\n    1. Calculate total amount, average transaction size\\n    2. Identify outliers (transactions > 2 standard deviations from mean)\\n    3. Group transactions by category\\n    4. Handle invalid inputs appropriately\\n  `;\\n\\n  const agent = new CodingAgent();\\n  const finalCode = await agent.processTask(task);\\n  console.log(\"\\\\nFinal Implementation:\\\\n\", finalCode);\\n}\\n\\nmain().catch(console.error);'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9yZWNpcGVzL2RhdGEvY29kaW5nLWFnZW50LnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFFTyxNQUFNQSxjQUFzQjtJQUNqQ0MsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxVQUFVO1FBQ1I7UUFDQTtRQUNBO0tBQ0Q7SUFDREMsWUFBYTtJQThMYkMsZ0JBQWlCO0FBK0xuQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9yZWNpcGVzL2RhdGEvY29kaW5nLWFnZW50LnRzPzRhYjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUmVjaXBlIH0gZnJvbSAnLi9pbmRleCc7XHJcblxyXG5leHBvcnQgY29uc3QgY29kaW5nQWdlbnQ6IFJlY2lwZSA9IHtcclxuICB0aXRsZTogXCJDb2RpbmcgQWdlbnRcIixcclxuICB0YWc6IFwiQWdlbnRcIixcclxuICBkZXNjcmlwdGlvbjogXCJBIHNvcGhpc3RpY2F0ZWQgd29ya2Zsb3cgZm9yIEFJLXBvd2VyZWQgY29kZSBnZW5lcmF0aW9uIHRoYXQgaW1wbGVtZW50cyBhIHJvYnVzdCBwcm9jZXNzIG9mIHRhc2sgY2xhcmlmaWNhdGlvbiwgY29kZSB3cml0aW5nLCBhbmQgdGVzdC1kcml2ZW4gZGV2ZWxvcG1lbnQuXCIsXHJcbiAgZXhwbGFuYXRpb246IFwiVGhlIGRpYWdyYW0gaWxsdXN0cmF0ZXMgYSBjb21wcmVoZW5zaXZlIGNvZGluZyBhZ2VudCB3b3JrZmxvdyB3aXRoIHR3byBtYWluIGxvb3BzLiBUaGUgZmlyc3QgbG9vcCAoJ1VudGlsIHRhc2tzIGNsZWFyJykgaGFuZGxlcyB0YXNrIGNsYXJpZmljYXRpb24gYmV0d2VlbiB0aGUgaHVtYW4gYW5kIExMTSB0aHJvdWdoIHRoZSBpbnRlcmZhY2UuIFRoZSBzZWNvbmQgbG9vcCAoJ1VudGlsIHRlc3RzIHBhc3MnKSBtYW5hZ2VzIHRoZSBjb2RlIGdlbmVyYXRpb24gYW5kIHRlc3RpbmcgcHJvY2Vzcywgd2hlcmUgdGhlIExMTSBpbnRlcmFjdHMgd2l0aCB0aGUgZW52aXJvbm1lbnQgdG8gd3JpdGUsIHRlc3QsIGFuZCByZWZpbmUgY29kZSB1bnRpbCBpdCBtZWV0cyB0aGUgc3BlY2lmaWVkIHJlcXVpcmVtZW50cy5cIixcclxuICB1c2VDYXNlczogW1xyXG4gICAgXCJBdXRvbWF0ZWQgQ29kZSBHZW5lcmF0aW9uOiBHZW5lcmF0ZSBjb2RlIGJhc2VkIG9uIG5hdHVyYWwgbGFuZ3VhZ2UgZGVzY3JpcHRpb25zIHdpdGggYnVpbHQtaW4gdGVzdGluZyBhbmQgdmFsaWRhdGlvbi5cIixcclxuICAgIFwiQ29kZSBSZWZhY3RvcmluZzogQW5hbHl6ZSBleGlzdGluZyBjb2RlIGFuZCBzdWdnZXN0IGltcHJvdmVtZW50cyB3aGlsZSBtYWludGFpbmluZyBmdW5jdGlvbmFsaXR5LlwiLFxyXG4gICAgXCJUZXN0LURyaXZlbiBEZXZlbG9wbWVudDogR2VuZXJhdGUgdGVzdCBjYXNlcyBhbmQgaW1wbGVtZW50YXRpb24gY29kZSBpdGVyYXRpdmVseS5cIlxyXG4gIF0sXHJcbiAgcHl0aG9uQ29kZTogYGZyb20gdHlwaW5nIGltcG9ydCBMaXN0LCBEaWN0LCBBbnksIE9wdGlvbmFsXHJcbmZyb20gcHlkYW50aWMgaW1wb3J0IEJhc2VNb2RlbFxyXG5mcm9tIGhlbHBlcnMgaW1wb3J0IHJ1bl9sbG0sIEpTT05fbGxtLCBleGVjdXRlX2NvbW1hbmRcclxuXHJcbmNsYXNzIFJlcXVpcmVtZW50KEJhc2VNb2RlbCk6XHJcbiAgICBcIlwiXCJSZXByZXNlbnRzIGEgY2xhcmlmaWVkIHJlcXVpcmVtZW50XCJcIlwiXHJcbiAgICBkZXNjcmlwdGlvbjogc3RyXHJcbiAgICBhY2NlcHRhbmNlX2NyaXRlcmlhOiBMaXN0W3N0cl1cclxuICAgIHRlc3RfY2FzZXM6IExpc3RbRGljdFtzdHIsIEFueV1dXHJcblxyXG5jbGFzcyBUZXN0UmVzdWx0KEJhc2VNb2RlbCk6XHJcbiAgICBcIlwiXCJSZXByZXNlbnRzIHRoZSByZXN1bHQgb2YgcnVubmluZyB0ZXN0c1wiXCJcIlxyXG4gICAgcGFzc2VkOiBib29sXHJcbiAgICBmYWlsZWRfdGVzdHM6IExpc3Rbc3RyXVxyXG4gICAgZXJyb3JfbWVzc2FnZXM6IExpc3Rbc3RyXVxyXG4gICAgY292ZXJhZ2U6IGZsb2F0XHJcblxyXG5jbGFzcyBDb2RpbmdBZ2VudDpcclxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcclxuICAgICAgICBzZWxmLnJlcXVpcmVtZW50czogTGlzdFtSZXF1aXJlbWVudF0gPSBbXVxyXG4gICAgICAgIHNlbGYuY3VycmVudF9jb2RlOiBzdHIgPSBcIlwiXHJcbiAgICAgICAgc2VsZi50ZXN0X2NvZGU6IHN0ciA9IFwiXCJcclxuICAgICAgICBcclxuICAgIGFzeW5jIGRlZiBjbGFyaWZ5X3JlcXVpcmVtZW50cyhzZWxmLCB0YXNrX2Rlc2NyaXB0aW9uOiBzdHIpIC0+IExpc3RbUmVxdWlyZW1lbnRdOlxyXG4gICAgICAgIFwiXCJcIkNsYXJpZnkgcmVxdWlyZW1lbnRzIHRocm91Z2ggaW50ZXJhY3Rpb24gd2l0aCBMTE1cIlwiXCJcclxuICAgICAgICBDTEFSSUZJQ0FUSU9OX1BST01QVCA9IFwiXCJcIkFuYWx5emUgdGhpcyBjb2RpbmcgdGFzayBhbmQgYnJlYWsgaXQgZG93biBpbnRvIGNsZWFyIHJlcXVpcmVtZW50cy5cclxuICAgICAgICBGb3IgZWFjaCByZXF1aXJlbWVudDpcclxuICAgICAgICAxLiBQcm92aWRlIGEgY2xlYXIgZGVzY3JpcHRpb25cclxuICAgICAgICAyLiBMaXN0IHNwZWNpZmljIGFjY2VwdGFuY2UgY3JpdGVyaWFcclxuICAgICAgICAzLiBEZWZpbmUgdGVzdCBjYXNlcyB3aXRoIGlucHV0cyBhbmQgZXhwZWN0ZWQgb3V0cHV0c1xyXG4gICAgICAgIFxyXG4gICAgICAgIFRhc2s6IHt0YXNrfVxyXG4gICAgICAgIFxyXG4gICAgICAgIFJldHVybiBhcyBKU09OIGFycmF5IG9mIHJlcXVpcmVtZW50cy5cIlwiXCJcclxuICAgICAgICBcclxuICAgICAgICBzZWxmLnJlcXVpcmVtZW50cyA9IGF3YWl0IEpTT05fbGxtKFxyXG4gICAgICAgICAgICBDTEFSSUZJQ0FUSU9OX1BST01QVC5mb3JtYXQodGFzaz10YXNrX2Rlc2NyaXB0aW9uKSxcclxuICAgICAgICAgICAgTGlzdFtSZXF1aXJlbWVudF1cclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHNlbGYucmVxdWlyZW1lbnRzXHJcbiAgICBcclxuICAgIGFzeW5jIGRlZiBnZW5lcmF0ZV90ZXN0X2NvZGUoc2VsZikgLT4gc3RyOlxyXG4gICAgICAgIFwiXCJcIkdlbmVyYXRlIHRlc3QgY29kZSBiYXNlZCBvbiByZXF1aXJlbWVudHNcIlwiXCJcclxuICAgICAgICBURVNUX1BST01QVCA9IFwiXCJcIkdlbmVyYXRlIHB5dGVzdCB0ZXN0IGNvZGUgZm9yIHRoZXNlIHJlcXVpcmVtZW50czpcclxuICAgICAgICB7cmVxdWlyZW1lbnRzfVxyXG4gICAgICAgIFxyXG4gICAgICAgIEluY2x1ZGU6XHJcbiAgICAgICAgMS4gVGVzdCBjYXNlcyBmb3IgZWFjaCByZXF1aXJlbWVudFxyXG4gICAgICAgIDIuIEVkZ2UgY2FzZXMgYW5kIGVycm9yIGNvbmRpdGlvbnNcclxuICAgICAgICAzLiBQcm9wZXIgdGVzdCBvcmdhbml6YXRpb24gYW5kIHNldHVwXHJcbiAgICAgICAgXHJcbiAgICAgICAgUmV0dXJuIG9ubHkgdGhlIHRlc3QgY29kZS5cIlwiXCJcclxuICAgICAgICBcclxuICAgICAgICBzZWxmLnRlc3RfY29kZSA9IGF3YWl0IHJ1bl9sbG0oXHJcbiAgICAgICAgICAgIFRFU1RfUFJPTVBULmZvcm1hdChyZXF1aXJlbWVudHM9c2VsZi5yZXF1aXJlbWVudHMpXHJcbiAgICAgICAgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiBzZWxmLnRlc3RfY29kZVxyXG4gICAgXHJcbiAgICBhc3luYyBkZWYgZ2VuZXJhdGVfaW1wbGVtZW50YXRpb24oc2VsZikgLT4gc3RyOlxyXG4gICAgICAgIFwiXCJcIkdlbmVyYXRlIGltcGxlbWVudGF0aW9uIGNvZGUgYmFzZWQgb24gcmVxdWlyZW1lbnRzIGFuZCB0ZXN0c1wiXCJcIlxyXG4gICAgICAgIElNUExFTUVOVEFUSU9OX1BST01QVCA9IFwiXCJcIkdlbmVyYXRlIGltcGxlbWVudGF0aW9uIGNvZGUgdGhhdCBzYXRpc2ZpZXMgdGhlc2UgcmVxdWlyZW1lbnRzIGFuZCBwYXNzZXMgdGhlc2UgdGVzdHM6XHJcbiAgICAgICAgXHJcbiAgICAgICAgUmVxdWlyZW1lbnRzOlxyXG4gICAgICAgIHtyZXF1aXJlbWVudHN9XHJcbiAgICAgICAgXHJcbiAgICAgICAgVGVzdCBDb2RlOlxyXG4gICAgICAgIHt0ZXN0X2NvZGV9XHJcbiAgICAgICAgXHJcbiAgICAgICAgRm9sbG93IHRoZXNlIGd1aWRlbGluZXM6XHJcbiAgICAgICAgMS4gV3JpdGUgY2xlYW4sIHdlbGwtZG9jdW1lbnRlZCBjb2RlXHJcbiAgICAgICAgMi4gSW5jbHVkZSB0eXBlIGhpbnRzXHJcbiAgICAgICAgMy4gSGFuZGxlIGVkZ2UgY2FzZXNcclxuICAgICAgICA0LiBGb2xsb3cgUEVQIDggc3R5bGUgZ3VpZGVcclxuICAgICAgICBcclxuICAgICAgICBSZXR1cm4gb25seSB0aGUgaW1wbGVtZW50YXRpb24gY29kZS5cIlwiXCJcclxuICAgICAgICBcclxuICAgICAgICBzZWxmLmN1cnJlbnRfY29kZSA9IGF3YWl0IHJ1bl9sbG0oXHJcbiAgICAgICAgICAgIElNUExFTUVOVEFUSU9OX1BST01QVC5mb3JtYXQoXHJcbiAgICAgICAgICAgICAgICByZXF1aXJlbWVudHM9c2VsZi5yZXF1aXJlbWVudHMsXHJcbiAgICAgICAgICAgICAgICB0ZXN0X2NvZGU9c2VsZi50ZXN0X2NvZGVcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc2VsZi5jdXJyZW50X2NvZGVcclxuICAgIFxyXG4gICAgYXN5bmMgZGVmIHJ1bl90ZXN0cyhzZWxmKSAtPiBUZXN0UmVzdWx0OlxyXG4gICAgICAgIFwiXCJcIlJ1biB0ZXN0cyBhbmQgcmV0dXJuIHJlc3VsdHNcIlwiXCJcclxuICAgICAgICB0cnk6XHJcbiAgICAgICAgICAgICMgU2F2ZSBjb2RlIHRvIHRlbXBvcmFyeSBmaWxlc1xyXG4gICAgICAgICAgICB3aXRoIG9wZW4oXCJ0ZW1wX2ltcGxlbWVudGF0aW9uLnB5XCIsIFwid1wiKSBhcyBmOlxyXG4gICAgICAgICAgICAgICAgZi53cml0ZShzZWxmLmN1cnJlbnRfY29kZSlcclxuICAgICAgICAgICAgd2l0aCBvcGVuKFwidGVtcF90ZXN0LnB5XCIsIFwid1wiKSBhcyBmOlxyXG4gICAgICAgICAgICAgICAgZi53cml0ZShzZWxmLnRlc3RfY29kZSlcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICMgUnVuIHB5dGVzdCB3aXRoIGNvdmVyYWdlXHJcbiAgICAgICAgICAgIHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVfY29tbWFuZChcclxuICAgICAgICAgICAgICAgIFwicHl0ZXN0IHRlbXBfdGVzdC5weSAtLWNvdj10ZW1wX2ltcGxlbWVudGF0aW9uIC12XCJcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgIyBQYXJzZSB0ZXN0IHJlc3VsdHNcclxuICAgICAgICAgICAgcmV0dXJuIFRlc3RSZXN1bHQoXHJcbiAgICAgICAgICAgICAgICBwYXNzZWQ9cmVzdWx0LnJldHVybmNvZGUgPT0gMCxcclxuICAgICAgICAgICAgICAgIGZhaWxlZF90ZXN0cz1zZWxmLl9wYXJzZV9mYWlsZWRfdGVzdHMocmVzdWx0Lm91dHB1dCksXHJcbiAgICAgICAgICAgICAgICBlcnJvcl9tZXNzYWdlcz1zZWxmLl9wYXJzZV9lcnJvcl9tZXNzYWdlcyhyZXN1bHQub3V0cHV0KSxcclxuICAgICAgICAgICAgICAgIGNvdmVyYWdlPXNlbGYuX3BhcnNlX2NvdmVyYWdlKHJlc3VsdC5vdXRwdXQpXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICBmaW5hbGx5OlxyXG4gICAgICAgICAgICAjIENsZWFudXAgdGVtcG9yYXJ5IGZpbGVzXHJcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVfY29tbWFuZChcInJtIHRlbXBfaW1wbGVtZW50YXRpb24ucHkgdGVtcF90ZXN0LnB5XCIpXHJcbiAgICBcclxuICAgIGFzeW5jIGRlZiBmaXhfaXNzdWVzKHNlbGYsIHRlc3RfcmVzdWx0OiBUZXN0UmVzdWx0KSAtPiBzdHI6XHJcbiAgICAgICAgXCJcIlwiRml4IGlzc3VlcyBiYXNlZCBvbiB0ZXN0IHJlc3VsdHNcIlwiXCJcclxuICAgICAgICBGSVhfUFJPTVBUID0gXCJcIlwiRml4IHRoZSBmb2xsb3dpbmcgaXNzdWVzIGluIHRoZSBjb2RlOlxyXG4gICAgICAgIFxyXG4gICAgICAgIEN1cnJlbnQgQ29kZTpcclxuICAgICAgICB7Y29kZX1cclxuICAgICAgICBcclxuICAgICAgICBUZXN0IFJlc3VsdHM6XHJcbiAgICAgICAgRmFpbGVkIFRlc3RzOiB7ZmFpbGVkX3Rlc3RzfVxyXG4gICAgICAgIEVycm9yIE1lc3NhZ2VzOiB7ZXJyb3JzfVxyXG4gICAgICAgIFxyXG4gICAgICAgIFJldHVybiB0aGUgZml4ZWQgaW1wbGVtZW50YXRpb24gY29kZS5cIlwiXCJcclxuICAgICAgICBcclxuICAgICAgICBzZWxmLmN1cnJlbnRfY29kZSA9IGF3YWl0IHJ1bl9sbG0oXHJcbiAgICAgICAgICAgIEZJWF9QUk9NUFQuZm9ybWF0KFxyXG4gICAgICAgICAgICAgICAgY29kZT1zZWxmLmN1cnJlbnRfY29kZSxcclxuICAgICAgICAgICAgICAgIGZhaWxlZF90ZXN0cz10ZXN0X3Jlc3VsdC5mYWlsZWRfdGVzdHMsXHJcbiAgICAgICAgICAgICAgICBlcnJvcnM9dGVzdF9yZXN1bHQuZXJyb3JfbWVzc2FnZXNcclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgICBcclxuICAgICAgICByZXR1cm4gc2VsZi5jdXJyZW50X2NvZGVcclxuICAgIFxyXG4gICAgYXN5bmMgZGVmIHByb2Nlc3NfdGFzayhzZWxmLCB0YXNrX2Rlc2NyaXB0aW9uOiBzdHIsIG1heF9pdGVyYXRpb25zOiBpbnQgPSA1KSAtPiBzdHI6XHJcbiAgICAgICAgXCJcIlwiUHJvY2VzcyBhIGNvZGluZyB0YXNrIGZyb20gc3RhcnQgdG8gZmluaXNoXCJcIlwiXHJcbiAgICAgICAgcHJpbnQoXCIxLiBDbGFyaWZ5aW5nIFJlcXVpcmVtZW50cy4uLlwiKVxyXG4gICAgICAgIHJlcXVpcmVtZW50cyA9IGF3YWl0IHNlbGYuY2xhcmlmeV9yZXF1aXJlbWVudHModGFza19kZXNjcmlwdGlvbilcclxuICAgICAgICBmb3IgaSwgcmVxIGluIGVudW1lcmF0ZShyZXF1aXJlbWVudHMsIDEpOlxyXG4gICAgICAgICAgICBwcmludChmXCJcXFxcblJlcXVpcmVtZW50IHtpfTpcIilcclxuICAgICAgICAgICAgcHJpbnQoZlwiRGVzY3JpcHRpb246IHtyZXEuZGVzY3JpcHRpb259XCIpXHJcbiAgICAgICAgICAgIHByaW50KFwiQWNjZXB0YW5jZSBDcml0ZXJpYTpcIilcclxuICAgICAgICAgICAgZm9yIGFjIGluIHJlcS5hY2NlcHRhbmNlX2NyaXRlcmlhOlxyXG4gICAgICAgICAgICAgICAgcHJpbnQoZlwiLSB7YWN9XCIpXHJcbiAgICAgICAgXHJcbiAgICAgICAgcHJpbnQoXCJcXFxcbjIuIEdlbmVyYXRpbmcgVGVzdHMuLi5cIilcclxuICAgICAgICB0ZXN0X2NvZGUgPSBhd2FpdCBzZWxmLmdlbmVyYXRlX3Rlc3RfY29kZSgpXHJcbiAgICAgICAgcHJpbnQoXCJUZXN0IGNvZGUgZ2VuZXJhdGVkLlwiKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHByaW50KFwiXFxcXG4zLiBJbXBsZW1lbnRpbmcgU29sdXRpb24uLi5cIilcclxuICAgICAgICBpbXBsZW1lbnRhdGlvbiA9IGF3YWl0IHNlbGYuZ2VuZXJhdGVfaW1wbGVtZW50YXRpb24oKVxyXG4gICAgICAgIHByaW50KFwiSW5pdGlhbCBpbXBsZW1lbnRhdGlvbiBjb21wbGV0ZS5cIilcclxuICAgICAgICBcclxuICAgICAgICBpdGVyYXRpb24gPSAwXHJcbiAgICAgICAgd2hpbGUgaXRlcmF0aW9uIDwgbWF4X2l0ZXJhdGlvbnM6XHJcbiAgICAgICAgICAgIHByaW50KGZcIlxcXFxuNC4gUnVubmluZyBUZXN0cyAoSXRlcmF0aW9uIHtpdGVyYXRpb24gKyAxfSkuLi5cIilcclxuICAgICAgICAgICAgdGVzdF9yZXN1bHQgPSBhd2FpdCBzZWxmLnJ1bl90ZXN0cygpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwcmludChmXCJUZXN0cyBQYXNzZWQ6IHt0ZXN0X3Jlc3VsdC5wYXNzZWR9XCIpXHJcbiAgICAgICAgICAgIHByaW50KGZcIkNvdmVyYWdlOiB7dGVzdF9yZXN1bHQuY292ZXJhZ2V9JVwiKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgaWYgdGVzdF9yZXN1bHQucGFzc2VkIGFuZCB0ZXN0X3Jlc3VsdC5jb3ZlcmFnZSA+PSA5MDpcclxuICAgICAgICAgICAgICAgIHByaW50KFwiXFxcXG5BbGwgdGVzdHMgcGFzc2VkIHdpdGggZ29vZCBjb3ZlcmFnZSFcIilcclxuICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBwcmludChcIlxcXFxuNS4gRml4aW5nIElzc3Vlcy4uLlwiKVxyXG4gICAgICAgICAgICBhd2FpdCBzZWxmLmZpeF9pc3N1ZXModGVzdF9yZXN1bHQpXHJcbiAgICAgICAgICAgIGl0ZXJhdGlvbiArPSAxXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHNlbGYuY3VycmVudF9jb2RlXHJcblxyXG4jIEV4YW1wbGUgdXNhZ2VcclxuYXN5bmMgZGVmIG1haW4oKTpcclxuICAgIHRhc2sgPSBcIlwiXCJcclxuICAgIENyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgcHJvY2Vzc2VzIGEgbGlzdCBvZiBmaW5hbmNpYWwgdHJhbnNhY3Rpb25zLlxyXG4gICAgUmVxdWlyZW1lbnRzOlxyXG4gICAgMS4gQ2FsY3VsYXRlIHRvdGFsIGFtb3VudCwgYXZlcmFnZSB0cmFuc2FjdGlvbiBzaXplXHJcbiAgICAyLiBJZGVudGlmeSBvdXRsaWVycyAodHJhbnNhY3Rpb25zID4gMiBzdGFuZGFyZCBkZXZpYXRpb25zIGZyb20gbWVhbilcclxuICAgIDMuIEdyb3VwIHRyYW5zYWN0aW9ucyBieSBjYXRlZ29yeVxyXG4gICAgNC4gSGFuZGxlIGludmFsaWQgaW5wdXRzIGFwcHJvcHJpYXRlbHlcclxuICAgIFwiXCJcIlxyXG4gICAgXHJcbiAgICBhZ2VudCA9IENvZGluZ0FnZW50KClcclxuICAgIGZpbmFsX2NvZGUgPSBhd2FpdCBhZ2VudC5wcm9jZXNzX3Rhc2sodGFzaylcclxuICAgIHByaW50KFwiXFxcXG5GaW5hbCBJbXBsZW1lbnRhdGlvbjpcXFxcblwiLCBmaW5hbF9jb2RlKVxyXG5cclxuaWYgX19uYW1lX18gPT0gXCJfX21haW5fX1wiOlxyXG4gICAgaW1wb3J0IGFzeW5jaW9cclxuICAgIGFzeW5jaW8ucnVuKG1haW4oKSlgLFxyXG4gIHR5cGVzY3JpcHRDb2RlOiBgaW1wb3J0IHsgTExNUmVzcG9uc2UgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgcnVuTExNLCBKU09OTExNLCBleGVjdXRlQ29tbWFuZCB9IGZyb20gJy4vaGVscGVycyc7XHJcblxyXG5pbnRlcmZhY2UgUmVxdWlyZW1lbnQge1xyXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmc7XHJcbiAgYWNjZXB0YW5jZV9jcml0ZXJpYTogc3RyaW5nW107XHJcbiAgdGVzdF9jYXNlczogQXJyYXk8UmVjb3JkPHN0cmluZywgYW55Pj47XHJcbn1cclxuXHJcbmludGVyZmFjZSBUZXN0UmVzdWx0IHtcclxuICBwYXNzZWQ6IGJvb2xlYW47XHJcbiAgZmFpbGVkX3Rlc3RzOiBzdHJpbmdbXTtcclxuICBlcnJvcl9tZXNzYWdlczogc3RyaW5nW107XHJcbiAgY292ZXJhZ2U6IG51bWJlcjtcclxufVxyXG5cclxuY2xhc3MgQ29kaW5nQWdlbnQge1xyXG4gIHByaXZhdGUgcmVxdWlyZW1lbnRzOiBSZXF1aXJlbWVudFtdID0gW107XHJcbiAgcHJpdmF0ZSBjdXJyZW50Q29kZTogc3RyaW5nID0gXCJcIjtcclxuICBwcml2YXRlIHRlc3RDb2RlOiBzdHJpbmcgPSBcIlwiO1xyXG5cclxuICBhc3luYyBjbGFyaWZ5UmVxdWlyZW1lbnRzKHRhc2tEZXNjcmlwdGlvbjogc3RyaW5nKTogUHJvbWlzZTxSZXF1aXJlbWVudFtdPiB7XHJcbiAgICBjb25zdCBDTEFSSUZJQ0FUSU9OX1BST01QVCA9IFxcYEFuYWx5emUgdGhpcyBjb2RpbmcgdGFzayBhbmQgYnJlYWsgaXQgZG93biBpbnRvIGNsZWFyIHJlcXVpcmVtZW50cy5cclxuICAgIEZvciBlYWNoIHJlcXVpcmVtZW50OlxyXG4gICAgMS4gUHJvdmlkZSBhIGNsZWFyIGRlc2NyaXB0aW9uXHJcbiAgICAyLiBMaXN0IHNwZWNpZmljIGFjY2VwdGFuY2UgY3JpdGVyaWFcclxuICAgIDMuIERlZmluZSB0ZXN0IGNhc2VzIHdpdGggaW5wdXRzIGFuZCBleHBlY3RlZCBvdXRwdXRzXHJcbiAgICBcclxuICAgIFRhc2s6IFxcJHt0YXNrRGVzY3JpcHRpb259XHJcbiAgICBcclxuICAgIFJldHVybiBhcyBKU09OIGFycmF5IG9mIHJlcXVpcmVtZW50cy5cXGA7XHJcblxyXG4gICAgdGhpcy5yZXF1aXJlbWVudHMgPSBhd2FpdCBKU09OTExNPFJlcXVpcmVtZW50W10+KENMQVJJRklDQVRJT05fUFJPTVBUKTtcclxuICAgIHJldHVybiB0aGlzLnJlcXVpcmVtZW50cztcclxuICB9XHJcblxyXG4gIGFzeW5jIGdlbmVyYXRlVGVzdENvZGUoKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIGNvbnN0IFRFU1RfUFJPTVBUID0gXFxgR2VuZXJhdGUgSmVzdCB0ZXN0IGNvZGUgZm9yIHRoZXNlIHJlcXVpcmVtZW50czpcclxuICAgIFxcJHtKU09OLnN0cmluZ2lmeSh0aGlzLnJlcXVpcmVtZW50cywgbnVsbCwgMil9XHJcbiAgICBcclxuICAgIEluY2x1ZGU6XHJcbiAgICAxLiBUZXN0IGNhc2VzIGZvciBlYWNoIHJlcXVpcmVtZW50XHJcbiAgICAyLiBFZGdlIGNhc2VzIGFuZCBlcnJvciBjb25kaXRpb25zXHJcbiAgICAzLiBQcm9wZXIgdGVzdCBvcmdhbml6YXRpb24gYW5kIHNldHVwXHJcbiAgICBcclxuICAgIFJldHVybiBvbmx5IHRoZSB0ZXN0IGNvZGUuXFxgO1xyXG5cclxuICAgIHRoaXMudGVzdENvZGUgPSBhd2FpdCBydW5MTE0oVEVTVF9QUk9NUFQpO1xyXG4gICAgcmV0dXJuIHRoaXMudGVzdENvZGU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZW5lcmF0ZUltcGxlbWVudGF0aW9uKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zdCBJTVBMRU1FTlRBVElPTl9QUk9NUFQgPSBcXGBHZW5lcmF0ZSBpbXBsZW1lbnRhdGlvbiBjb2RlIHRoYXQgc2F0aXNmaWVzIHRoZXNlIHJlcXVpcmVtZW50cyBhbmQgcGFzc2VzIHRoZXNlIHRlc3RzOlxyXG4gICAgXHJcbiAgICBSZXF1aXJlbWVudHM6XHJcbiAgICBcXCR7SlNPTi5zdHJpbmdpZnkodGhpcy5yZXF1aXJlbWVudHMsIG51bGwsIDIpfVxyXG4gICAgXHJcbiAgICBUZXN0IENvZGU6XHJcbiAgICBcXCR7dGhpcy50ZXN0Q29kZX1cclxuICAgIFxyXG4gICAgRm9sbG93IHRoZXNlIGd1aWRlbGluZXM6XHJcbiAgICAxLiBXcml0ZSBjbGVhbiwgd2VsbC1kb2N1bWVudGVkIGNvZGVcclxuICAgIDIuIEluY2x1ZGUgVHlwZVNjcmlwdCB0eXBlc1xyXG4gICAgMy4gSGFuZGxlIGVkZ2UgY2FzZXNcclxuICAgIDQuIEZvbGxvdyBzdGFuZGFyZCBzdHlsZSBndWlkZVxyXG4gICAgXHJcbiAgICBSZXR1cm4gb25seSB0aGUgaW1wbGVtZW50YXRpb24gY29kZS5cXGA7XHJcblxyXG4gICAgdGhpcy5jdXJyZW50Q29kZSA9IGF3YWl0IHJ1bkxMTShJTVBMRU1FTlRBVElPTl9QUk9NUFQpO1xyXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvZGU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBydW5UZXN0cygpOiBQcm9taXNlPFRlc3RSZXN1bHQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFNhdmUgY29kZSB0byB0ZW1wb3JhcnkgZmlsZXNcclxuICAgICAgYXdhaXQgZXhlY3V0ZUNvbW1hbmQoXFxgXHJcbiAgICAgICAgZWNobyAnXFwke3RoaXMuY3VycmVudENvZGV9JyA+IHRlbXBfaW1wbGVtZW50YXRpb24udHNcclxuICAgICAgICBlY2hvICdcXCR7dGhpcy50ZXN0Q29kZX0nID4gdGVtcF90ZXN0LnRzXHJcbiAgICAgIFxcYCk7XHJcblxyXG4gICAgICAvLyBSdW4gSmVzdCB3aXRoIGNvdmVyYWdlXHJcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGV4ZWN1dGVDb21tYW5kKFxyXG4gICAgICAgIFwiamVzdCB0ZW1wX3Rlc3QudHMgLS1jb3ZlcmFnZSAtLWpzb25cIlxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gUGFyc2UgdGVzdCByZXN1bHRzIGZyb20gSlNPTiBvdXRwdXRcclxuICAgICAgY29uc3QgdGVzdFJlc3VsdHMgPSBKU09OLnBhcnNlKHJlc3VsdC5vdXRwdXQpO1xyXG5cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBwYXNzZWQ6IHRlc3RSZXN1bHRzLnN1Y2Nlc3MsXHJcbiAgICAgICAgZmFpbGVkX3Rlc3RzOiB0aGlzLnBhcnNlRmFpbGVkVGVzdHModGVzdFJlc3VsdHMpLFxyXG4gICAgICAgIGVycm9yX21lc3NhZ2VzOiB0aGlzLnBhcnNlRXJyb3JNZXNzYWdlcyh0ZXN0UmVzdWx0cyksXHJcbiAgICAgICAgY292ZXJhZ2U6IHRoaXMucGFyc2VDb3ZlcmFnZSh0ZXN0UmVzdWx0cylcclxuICAgICAgfTtcclxuICAgIH0gZmluYWxseSB7XHJcbiAgICAgIC8vIENsZWFudXAgdGVtcG9yYXJ5IGZpbGVzXHJcbiAgICAgIGF3YWl0IGV4ZWN1dGVDb21tYW5kKFwicm0gdGVtcF9pbXBsZW1lbnRhdGlvbi50cyB0ZW1wX3Rlc3QudHNcIik7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBhc3luYyBmaXhJc3N1ZXModGVzdFJlc3VsdDogVGVzdFJlc3VsdCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zdCBGSVhfUFJPTVBUID0gXFxgRml4IHRoZSBmb2xsb3dpbmcgaXNzdWVzIGluIHRoZSBjb2RlOlxyXG4gICAgXHJcbiAgICBDdXJyZW50IENvZGU6XHJcbiAgICBcXCR7dGhpcy5jdXJyZW50Q29kZX1cclxuICAgIFxyXG4gICAgVGVzdCBSZXN1bHRzOlxyXG4gICAgRmFpbGVkIFRlc3RzOiBcXCR7SlNPTi5zdHJpbmdpZnkodGVzdFJlc3VsdC5mYWlsZWRfdGVzdHMpfVxyXG4gICAgRXJyb3IgTWVzc2FnZXM6IFxcJHtKU09OLnN0cmluZ2lmeSh0ZXN0UmVzdWx0LmVycm9yX21lc3NhZ2VzKX1cclxuICAgIFxyXG4gICAgUmV0dXJuIHRoZSBmaXhlZCBpbXBsZW1lbnRhdGlvbiBjb2RlLlxcYDtcclxuXHJcbiAgICB0aGlzLmN1cnJlbnRDb2RlID0gYXdhaXQgcnVuTExNKEZJWF9QUk9NUFQpO1xyXG4gICAgcmV0dXJuIHRoaXMuY3VycmVudENvZGU7XHJcbiAgfVxyXG5cclxuICBhc3luYyBwcm9jZXNzVGFzayhcclxuICAgIHRhc2tEZXNjcmlwdGlvbjogc3RyaW5nLFxyXG4gICAgbWF4SXRlcmF0aW9uczogbnVtYmVyID0gNVxyXG4gICk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgICBjb25zb2xlLmxvZyhcIjEuIENsYXJpZnlpbmcgUmVxdWlyZW1lbnRzLi4uXCIpO1xyXG4gICAgY29uc3QgcmVxdWlyZW1lbnRzID0gYXdhaXQgdGhpcy5jbGFyaWZ5UmVxdWlyZW1lbnRzKHRhc2tEZXNjcmlwdGlvbik7XHJcbiAgICByZXF1aXJlbWVudHMuZm9yRWFjaCgocmVxLCBpKSA9PiB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxcYFxcXFxuUmVxdWlyZW1lbnQgXFwke2kgKyAxfTpcXGApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcXGBEZXNjcmlwdGlvbjogXFwke3JlcS5kZXNjcmlwdGlvbn1cXGApO1xyXG4gICAgICBjb25zb2xlLmxvZyhcIkFjY2VwdGFuY2UgQ3JpdGVyaWE6XCIpO1xyXG4gICAgICByZXEuYWNjZXB0YW5jZV9jcml0ZXJpYS5mb3JFYWNoKGFjID0+IGNvbnNvbGUubG9nKFxcYC0gXFwke2FjfVxcYCkpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJcXFxcbjIuIEdlbmVyYXRpbmcgVGVzdHMuLi5cIik7XHJcbiAgICBhd2FpdCB0aGlzLmdlbmVyYXRlVGVzdENvZGUoKTtcclxuICAgIGNvbnNvbGUubG9nKFwiVGVzdCBjb2RlIGdlbmVyYXRlZC5cIik7XHJcblxyXG4gICAgY29uc29sZS5sb2coXCJcXFxcbjMuIEltcGxlbWVudGluZyBTb2x1dGlvbi4uLlwiKTtcclxuICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbXBsZW1lbnRhdGlvbigpO1xyXG4gICAgY29uc29sZS5sb2coXCJJbml0aWFsIGltcGxlbWVudGF0aW9uIGNvbXBsZXRlLlwiKTtcclxuXHJcbiAgICBsZXQgaXRlcmF0aW9uID0gMDtcclxuICAgIHdoaWxlIChpdGVyYXRpb24gPCBtYXhJdGVyYXRpb25zKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKFxcYFxcXFxuNC4gUnVubmluZyBUZXN0cyAoSXRlcmF0aW9uIFxcJHtpdGVyYXRpb24gKyAxfSkuLi5cXGApO1xyXG4gICAgICBjb25zdCB0ZXN0UmVzdWx0ID0gYXdhaXQgdGhpcy5ydW5UZXN0cygpO1xyXG5cclxuICAgICAgY29uc29sZS5sb2coXFxgVGVzdHMgUGFzc2VkOiBcXCR7dGVzdFJlc3VsdC5wYXNzZWR9XFxgKTtcclxuICAgICAgY29uc29sZS5sb2coXFxgQ292ZXJhZ2U6IFxcJHt0ZXN0UmVzdWx0LmNvdmVyYWdlfSVcXGApO1xyXG5cclxuICAgICAgaWYgKHRlc3RSZXN1bHQucGFzc2VkICYmIHRlc3RSZXN1bHQuY292ZXJhZ2UgPj0gOTApIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhcIlxcXFxuQWxsIHRlc3RzIHBhc3NlZCB3aXRoIGdvb2QgY292ZXJhZ2UhXCIpO1xyXG4gICAgICAgIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zb2xlLmxvZyhcIlxcXFxuNS4gRml4aW5nIElzc3Vlcy4uLlwiKTtcclxuICAgICAgYXdhaXQgdGhpcy5maXhJc3N1ZXModGVzdFJlc3VsdCk7XHJcbiAgICAgIGl0ZXJhdGlvbisrO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLmN1cnJlbnRDb2RlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwYXJzZUZhaWxlZFRlc3RzKHRlc3RSZXN1bHRzOiBhbnkpOiBzdHJpbmdbXSB7XHJcbiAgICAvLyBJbXBsZW1lbnRhdGlvbiBvZiB0ZXN0IHJlc3VsdHMgcGFyc2luZ1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwYXJzZUVycm9yTWVzc2FnZXModGVzdFJlc3VsdHM6IGFueSk6IHN0cmluZ1tdIHtcclxuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIGVycm9yIG1lc3NhZ2UgcGFyc2luZ1xyXG4gICAgcmV0dXJuIFtdO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBwYXJzZUNvdmVyYWdlKHRlc3RSZXN1bHRzOiBhbnkpOiBudW1iZXIge1xyXG4gICAgLy8gSW1wbGVtZW50YXRpb24gb2YgY292ZXJhZ2UgcGFyc2luZ1xyXG4gICAgcmV0dXJuIDA7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeGFtcGxlIHVzYWdlXHJcbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgY29uc3QgdGFzayA9IFxcYFxyXG4gICAgQ3JlYXRlIGEgZnVuY3Rpb24gdGhhdCBwcm9jZXNzZXMgYSBsaXN0IG9mIGZpbmFuY2lhbCB0cmFuc2FjdGlvbnMuXHJcbiAgICBSZXF1aXJlbWVudHM6XHJcbiAgICAxLiBDYWxjdWxhdGUgdG90YWwgYW1vdW50LCBhdmVyYWdlIHRyYW5zYWN0aW9uIHNpemVcclxuICAgIDIuIElkZW50aWZ5IG91dGxpZXJzICh0cmFuc2FjdGlvbnMgPiAyIHN0YW5kYXJkIGRldmlhdGlvbnMgZnJvbSBtZWFuKVxyXG4gICAgMy4gR3JvdXAgdHJhbnNhY3Rpb25zIGJ5IGNhdGVnb3J5XHJcbiAgICA0LiBIYW5kbGUgaW52YWxpZCBpbnB1dHMgYXBwcm9wcmlhdGVseVxyXG4gIFxcYDtcclxuXHJcbiAgY29uc3QgYWdlbnQgPSBuZXcgQ29kaW5nQWdlbnQoKTtcclxuICBjb25zdCBmaW5hbENvZGUgPSBhd2FpdCBhZ2VudC5wcm9jZXNzVGFzayh0YXNrKTtcclxuICBjb25zb2xlLmxvZyhcIlxcXFxuRmluYWwgSW1wbGVtZW50YXRpb246XFxcXG5cIiwgZmluYWxDb2RlKTtcclxufVxyXG5cclxubWFpbigpLmNhdGNoKGNvbnNvbGUuZXJyb3IpO2BcclxufTtcclxuIl0sIm5hbWVzIjpbImNvZGluZ0FnZW50IiwidGl0bGUiLCJ0YWciLCJkZXNjcmlwdGlvbiIsImV4cGxhbmF0aW9uIiwidXNlQ2FzZXMiLCJweXRob25Db2RlIiwidHlwZXNjcmlwdENvZGUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/recipes/data/coding-agent.ts\n"));

/***/ })

});