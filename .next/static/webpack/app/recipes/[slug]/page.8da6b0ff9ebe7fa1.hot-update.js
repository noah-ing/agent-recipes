"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/recipes/[slug]/page",{

/***/ "(app-pages-browser)/./app/recipes/data/orchestrator-workers.ts":
/*!**************************************************!*\
  !*** ./app/recipes/data/orchestrator-workers.ts ***!
  \**************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   orchestratorWorkers: function() { return /* binding */ orchestratorWorkers; }\n/* harmony export */ });\nconst orchestratorWorkers = {\n    title: \"Orchestrator-workers\",\n    tag: \"Workflow\",\n    description: \"The Orchestrator-Workers pattern is a hierarchical workflow where a central 'orchestrator' LLM oversees and coordinates multiple 'worker' LLMs. This approach is particularly effective for complex, multi-step tasks that require different types of expertise or processing.\",\n    explanation: \"In the diagram, the orchestrator receives the initial input and task, analyzes the problem, breaks it down into subtasks, and delegates these to specialized worker LLMs. Each worker focuses on its assigned subtask and returns its results to the orchestrator, which then synthesizes these individual results into a final output.\",\n    useCases: [\n        \"Complex Research Tasks: Orchestrator breaks down research questions and coordinates data collection, analysis, and summary tasks.\",\n        \"Multi-component Software Development: Plan architecture and delegate frontend, backend, and database design tasks.\",\n        \"Interdisciplinary Problem Solving: Coordinate between workers specializing in different domains for comprehensive solutions.\"\n    ],\n    pythonCode: 'from typing import List, Dict, Any\\nfrom pydantic import BaseModel\\nfrom helpers import run_llm, JSON_llm\\n\\nclass Task(BaseModel):\\n    \"\"\"Represents a subtask in the workflow\"\"\"\\n    description: str\\n    worker: str\\n    priority: int\\n    dependencies: List[int] = []\\n\\nclass WorkerResult(BaseModel):\\n    \"\"\"Represents the result from a worker\"\"\"\\n    task_id: int\\n    result: str\\n    status: str\\n\\nasync def orchestrator_workflow(project_request: str) -> str:\\n    \"\"\"Orchestrate multiple LLM workers to complete a complex project.\"\"\"\\n    \\n    # Step 1: Orchestrator analyzes and breaks down the project\\n    PLANNING_PROMPT = \"\"\"Break down this project request into specific tasks.\\n    For each task specify:\\n    1. Task description\\n    2. Which worker should handle it (choose from: researcher, architect, developer, reviewer)\\n    3. Priority (1-5, 1 being highest)\\n    4. Dependencies (task IDs that must be completed first)\\n    Return as JSON array of tasks.\"\"\"\\n\\n    tasks = JSON_llm(\\n        f\"{PLANNING_PROMPT}\\\\nProject: {project_request}\",\\n        List[Task]\\n    )\\n    \\n    # Sort tasks by priority and dependencies\\n    tasks.sort(key=lambda x: (len(x.dependencies), x.priority))\\n    \\n    # Step 2: Execute tasks through workers\\n    results: Dict[int, WorkerResult] = {}\\n    \\n    for i, task in enumerate(tasks):\\n        # Wait for dependencies to complete\\n        for dep in task.dependencies:\\n            if dep not in results or results[dep].status != \"completed\":\\n                continue\\n                \\n        # Select appropriate worker prompt based on role\\n        worker_prompts = {\\n            \"researcher\": \"Research and provide information about:\",\\n            \"architect\": \"Design the architecture for:\",\\n            \"developer\": \"Write code to implement:\",\\n            \"reviewer\": \"Review and provide feedback on:\"\\n        }\\n        \\n        # Execute worker task\\n        worker_result = await run_llm(\\n            f\"{worker_prompts[task.worker]}\\\\n{task.description}\\\\n\\\\n\" +\\n            \"Previous relevant results:\\\\n\" +\\n            \"\\\\n\".join([\\n                f\"Task {dep}: {results[dep].result}\"\\n                for dep in task.dependencies\\n                if dep in results\\n            ]),\\n            model=f\"specialized/{task.worker}-llm\"\\n        )\\n        \\n        # Store result\\n        results[i] = WorkerResult(\\n            task_id=i,\\n            result=worker_result,\\n            status=\"completed\"\\n        )\\n    \\n    # Step 3: Orchestrator synthesizes final result\\n    SYNTHESIS_PROMPT = \"\"\"Synthesize the results of all completed tasks into a \\n    coherent final deliverable. Ensure all components work together and meet the \\n    original project requirements.\"\"\"\\n    \\n    final_result = await run_llm(\\n        f\"{SYNTHESIS_PROMPT}\\\\n\\\\nProject Request: {project_request}\\\\n\\\\n\" +\\n        \"Task Results:\\\\n\" +\\n        \"\\\\n\".join([\\n            f\"Task {i}: {result.result}\"\\n            for i, result in results.items()\\n        ])\\n    )\\n    \\n    return final_result\\n\\n# Example usage\\nasync def main():\\n    project = \"\"\"\\n    Create a web application for task management with the following requirements:\\n    1. User authentication\\n    2. CRUD operations for tasks\\n    3. Task categorization and filtering\\n    4. Responsive design\\n    5. Data persistence\\n    \"\"\"\\n    \\n    result = await orchestrator_workflow(project)\\n    print(\"Final Project Deliverable:\\\\n\", result)\\n\\nif __name__ == \"__main__\":\\n    import asyncio\\n    asyncio.run(main())',\n    typescriptCode: 'import { LLMResponse } from \\'./types\\';\\nimport { runLLM, JSONLLM } from \\'./helpers\\';\\n\\ninterface Task {\\n  description: string;\\n  worker: string;\\n  priority: number;\\n  dependencies: number[];\\n}\\n\\ninterface WorkerResult {\\n  task_id: number;\\n  result: string;\\n  status: string;\\n}\\n\\nasync function orchestratorWorkflow(projectRequest: string): Promise<string> {\\n  // Step 1: Orchestrator analyzes and breaks down the project\\n  const PLANNING_PROMPT = `Break down this project request into specific tasks.\\n  For each task specify:\\n  1. Task description\\n  2. Which worker should handle it (choose from: researcher, architect, developer, reviewer)\\n  3. Priority (1-5, 1 being highest)\\n  4. Dependencies (task IDs that must be completed first)\\n  Return as JSON array of tasks.`;\\n\\n  const tasks = await JSONLLM<Task[]>(\\n    `${PLANNING_PROMPT}\\\\nProject: ${projectRequest}`\\n  );\\n\\n  // Sort tasks by priority and dependencies\\n  tasks.sort((a, b) => \\n    (a.dependencies.length - b.dependencies.length) || (a.priority - b.priority)\\n  );\\n\\n  // Step 2: Execute tasks through workers\\n  const results: Record<number, WorkerResult> = {};\\n\\n  for (let i = 0; i < tasks.length; i++) {\\n    const task = tasks[i];\\n\\n    // Wait for dependencies to complete\\n    const dependenciesComplete = task.dependencies.every(\\n      dep => dep in results && results[dep].status === \"completed\"\\n    );\\n    if (!dependenciesComplete) continue;\\n\\n    // Select appropriate worker prompt based on role\\n    const workerPrompts: Record<string, string> = {\\n      researcher: \"Research and provide information about:\",\\n      architect: \"Design the architecture for:\",\\n      developer: \"Write code to implement:\",\\n      reviewer: \"Review and provide feedback on:\"\\n    };\\n\\n    // Execute worker task\\n    const workerResult = await runLLM({\\n      prompt: `${workerPrompts[task.worker]}\\\\n${task.description}\\\\n\\\\n` +\\n        \"Previous relevant results:\\\\n\" +\\n        task.dependencies\\n          .filter(dep => dep in results)\\n          .map(dep => `Task ${dep}: ${results[dep].result}`)\\n          .join(\"\\\\n\"),\\n      model: `specialized/${task.worker}-llm`\\n    });\\n\\n    // Store result\\n    results[i] = {\\n      task_id: i,\\n      result: workerResult,\\n      status: \"completed\"\\n    };\\n  }\\n\\n  // Step 3: Orchestrator synthesizes final result\\n  const SYNTHESIS_PROMPT = `Synthesize the results of all completed tasks into a \\n  coherent final deliverable. Ensure all components work together and meet the \\n  original project requirements.`;\\n\\n  const finalResult = await runLLM({\\n    prompt: `${SYNTHESIS_PROMPT}\\\\n\\\\nProject Request: ${projectRequest}\\\\n\\\\n` +\\n      \"Task Results:\\\\n\" +\\n      Object.entries(results)\\n        .map(([i, result]) => `Task ${i}: ${result.result}`)\\n        .join(\"\\\\n\")\\n  });\\n\\n  return finalResult;\\n}\\n\\n// Example usage\\nasync function main() {\\n  const project = `\\n    Create a web application for task management with the following requirements:\\n    1. User authentication\\n    2. CRUD operations for tasks\\n    3. Task categorization and filtering\\n    4. Responsive design\\n    5. Data persistence\\n  `;\\n\\n  const result = await orchestratorWorkflow(project);\\n  console.log(\"Final Project Deliverable:\\\\n\", result);\\n}\\n\\nmain().catch(console.error);'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9yZWNpcGVzL2RhdGEvb3JjaGVzdHJhdG9yLXdvcmtlcnMudHMiLCJtYXBwaW5ncyI6Ijs7OztBQUVPLE1BQU1BLHNCQUE4QjtJQUN6Q0MsT0FBTztJQUNQQyxLQUFLO0lBQ0xDLGFBQWE7SUFDYkMsYUFBYTtJQUNiQyxVQUFVO1FBQ1I7UUFDQTtRQUNBO0tBQ0Q7SUFDREMsWUFBYTtJQTBHYkMsZ0JBQWlCO0FBMEduQixFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL2FwcC9yZWNpcGVzL2RhdGEvb3JjaGVzdHJhdG9yLXdvcmtlcnMudHM/MGY4ZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWNpcGUgfSBmcm9tICcuL2luZGV4JztcclxuXHJcbmV4cG9ydCBjb25zdCBvcmNoZXN0cmF0b3JXb3JrZXJzOiBSZWNpcGUgPSB7XHJcbiAgdGl0bGU6IFwiT3JjaGVzdHJhdG9yLXdvcmtlcnNcIixcclxuICB0YWc6IFwiV29ya2Zsb3dcIixcclxuICBkZXNjcmlwdGlvbjogXCJUaGUgT3JjaGVzdHJhdG9yLVdvcmtlcnMgcGF0dGVybiBpcyBhIGhpZXJhcmNoaWNhbCB3b3JrZmxvdyB3aGVyZSBhIGNlbnRyYWwgJ29yY2hlc3RyYXRvcicgTExNIG92ZXJzZWVzIGFuZCBjb29yZGluYXRlcyBtdWx0aXBsZSAnd29ya2VyJyBMTE1zLiBUaGlzIGFwcHJvYWNoIGlzIHBhcnRpY3VsYXJseSBlZmZlY3RpdmUgZm9yIGNvbXBsZXgsIG11bHRpLXN0ZXAgdGFza3MgdGhhdCByZXF1aXJlIGRpZmZlcmVudCB0eXBlcyBvZiBleHBlcnRpc2Ugb3IgcHJvY2Vzc2luZy5cIixcclxuICBleHBsYW5hdGlvbjogXCJJbiB0aGUgZGlhZ3JhbSwgdGhlIG9yY2hlc3RyYXRvciByZWNlaXZlcyB0aGUgaW5pdGlhbCBpbnB1dCBhbmQgdGFzaywgYW5hbHl6ZXMgdGhlIHByb2JsZW0sIGJyZWFrcyBpdCBkb3duIGludG8gc3VidGFza3MsIGFuZCBkZWxlZ2F0ZXMgdGhlc2UgdG8gc3BlY2lhbGl6ZWQgd29ya2VyIExMTXMuIEVhY2ggd29ya2VyIGZvY3VzZXMgb24gaXRzIGFzc2lnbmVkIHN1YnRhc2sgYW5kIHJldHVybnMgaXRzIHJlc3VsdHMgdG8gdGhlIG9yY2hlc3RyYXRvciwgd2hpY2ggdGhlbiBzeW50aGVzaXplcyB0aGVzZSBpbmRpdmlkdWFsIHJlc3VsdHMgaW50byBhIGZpbmFsIG91dHB1dC5cIixcclxuICB1c2VDYXNlczogW1xyXG4gICAgXCJDb21wbGV4IFJlc2VhcmNoIFRhc2tzOiBPcmNoZXN0cmF0b3IgYnJlYWtzIGRvd24gcmVzZWFyY2ggcXVlc3Rpb25zIGFuZCBjb29yZGluYXRlcyBkYXRhIGNvbGxlY3Rpb24sIGFuYWx5c2lzLCBhbmQgc3VtbWFyeSB0YXNrcy5cIixcclxuICAgIFwiTXVsdGktY29tcG9uZW50IFNvZnR3YXJlIERldmVsb3BtZW50OiBQbGFuIGFyY2hpdGVjdHVyZSBhbmQgZGVsZWdhdGUgZnJvbnRlbmQsIGJhY2tlbmQsIGFuZCBkYXRhYmFzZSBkZXNpZ24gdGFza3MuXCIsXHJcbiAgICBcIkludGVyZGlzY2lwbGluYXJ5IFByb2JsZW0gU29sdmluZzogQ29vcmRpbmF0ZSBiZXR3ZWVuIHdvcmtlcnMgc3BlY2lhbGl6aW5nIGluIGRpZmZlcmVudCBkb21haW5zIGZvciBjb21wcmVoZW5zaXZlIHNvbHV0aW9ucy5cIlxyXG4gIF0sXHJcbiAgcHl0aG9uQ29kZTogYGZyb20gdHlwaW5nIGltcG9ydCBMaXN0LCBEaWN0LCBBbnlcclxuZnJvbSBweWRhbnRpYyBpbXBvcnQgQmFzZU1vZGVsXHJcbmZyb20gaGVscGVycyBpbXBvcnQgcnVuX2xsbSwgSlNPTl9sbG1cclxuXHJcbmNsYXNzIFRhc2soQmFzZU1vZGVsKTpcclxuICAgIFwiXCJcIlJlcHJlc2VudHMgYSBzdWJ0YXNrIGluIHRoZSB3b3JrZmxvd1wiXCJcIlxyXG4gICAgZGVzY3JpcHRpb246IHN0clxyXG4gICAgd29ya2VyOiBzdHJcclxuICAgIHByaW9yaXR5OiBpbnRcclxuICAgIGRlcGVuZGVuY2llczogTGlzdFtpbnRdID0gW11cclxuXHJcbmNsYXNzIFdvcmtlclJlc3VsdChCYXNlTW9kZWwpOlxyXG4gICAgXCJcIlwiUmVwcmVzZW50cyB0aGUgcmVzdWx0IGZyb20gYSB3b3JrZXJcIlwiXCJcclxuICAgIHRhc2tfaWQ6IGludFxyXG4gICAgcmVzdWx0OiBzdHJcclxuICAgIHN0YXR1czogc3RyXHJcblxyXG5hc3luYyBkZWYgb3JjaGVzdHJhdG9yX3dvcmtmbG93KHByb2plY3RfcmVxdWVzdDogc3RyKSAtPiBzdHI6XHJcbiAgICBcIlwiXCJPcmNoZXN0cmF0ZSBtdWx0aXBsZSBMTE0gd29ya2VycyB0byBjb21wbGV0ZSBhIGNvbXBsZXggcHJvamVjdC5cIlwiXCJcclxuICAgIFxyXG4gICAgIyBTdGVwIDE6IE9yY2hlc3RyYXRvciBhbmFseXplcyBhbmQgYnJlYWtzIGRvd24gdGhlIHByb2plY3RcclxuICAgIFBMQU5OSU5HX1BST01QVCA9IFwiXCJcIkJyZWFrIGRvd24gdGhpcyBwcm9qZWN0IHJlcXVlc3QgaW50byBzcGVjaWZpYyB0YXNrcy5cclxuICAgIEZvciBlYWNoIHRhc2sgc3BlY2lmeTpcclxuICAgIDEuIFRhc2sgZGVzY3JpcHRpb25cclxuICAgIDIuIFdoaWNoIHdvcmtlciBzaG91bGQgaGFuZGxlIGl0IChjaG9vc2UgZnJvbTogcmVzZWFyY2hlciwgYXJjaGl0ZWN0LCBkZXZlbG9wZXIsIHJldmlld2VyKVxyXG4gICAgMy4gUHJpb3JpdHkgKDEtNSwgMSBiZWluZyBoaWdoZXN0KVxyXG4gICAgNC4gRGVwZW5kZW5jaWVzICh0YXNrIElEcyB0aGF0IG11c3QgYmUgY29tcGxldGVkIGZpcnN0KVxyXG4gICAgUmV0dXJuIGFzIEpTT04gYXJyYXkgb2YgdGFza3MuXCJcIlwiXHJcblxyXG4gICAgdGFza3MgPSBKU09OX2xsbShcclxuICAgICAgICBmXCJ7UExBTk5JTkdfUFJPTVBUfVxcXFxuUHJvamVjdDoge3Byb2plY3RfcmVxdWVzdH1cIixcclxuICAgICAgICBMaXN0W1Rhc2tdXHJcbiAgICApXHJcbiAgICBcclxuICAgICMgU29ydCB0YXNrcyBieSBwcmlvcml0eSBhbmQgZGVwZW5kZW5jaWVzXHJcbiAgICB0YXNrcy5zb3J0KGtleT1sYW1iZGEgeDogKGxlbih4LmRlcGVuZGVuY2llcyksIHgucHJpb3JpdHkpKVxyXG4gICAgXHJcbiAgICAjIFN0ZXAgMjogRXhlY3V0ZSB0YXNrcyB0aHJvdWdoIHdvcmtlcnNcclxuICAgIHJlc3VsdHM6IERpY3RbaW50LCBXb3JrZXJSZXN1bHRdID0ge31cclxuICAgIFxyXG4gICAgZm9yIGksIHRhc2sgaW4gZW51bWVyYXRlKHRhc2tzKTpcclxuICAgICAgICAjIFdhaXQgZm9yIGRlcGVuZGVuY2llcyB0byBjb21wbGV0ZVxyXG4gICAgICAgIGZvciBkZXAgaW4gdGFzay5kZXBlbmRlbmNpZXM6XHJcbiAgICAgICAgICAgIGlmIGRlcCBub3QgaW4gcmVzdWx0cyBvciByZXN1bHRzW2RlcF0uc3RhdHVzICE9IFwiY29tcGxldGVkXCI6XHJcbiAgICAgICAgICAgICAgICBjb250aW51ZVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgIyBTZWxlY3QgYXBwcm9wcmlhdGUgd29ya2VyIHByb21wdCBiYXNlZCBvbiByb2xlXHJcbiAgICAgICAgd29ya2VyX3Byb21wdHMgPSB7XHJcbiAgICAgICAgICAgIFwicmVzZWFyY2hlclwiOiBcIlJlc2VhcmNoIGFuZCBwcm92aWRlIGluZm9ybWF0aW9uIGFib3V0OlwiLFxyXG4gICAgICAgICAgICBcImFyY2hpdGVjdFwiOiBcIkRlc2lnbiB0aGUgYXJjaGl0ZWN0dXJlIGZvcjpcIixcclxuICAgICAgICAgICAgXCJkZXZlbG9wZXJcIjogXCJXcml0ZSBjb2RlIHRvIGltcGxlbWVudDpcIixcclxuICAgICAgICAgICAgXCJyZXZpZXdlclwiOiBcIlJldmlldyBhbmQgcHJvdmlkZSBmZWVkYmFjayBvbjpcIlxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAjIEV4ZWN1dGUgd29ya2VyIHRhc2tcclxuICAgICAgICB3b3JrZXJfcmVzdWx0ID0gYXdhaXQgcnVuX2xsbShcclxuICAgICAgICAgICAgZlwie3dvcmtlcl9wcm9tcHRzW3Rhc2sud29ya2VyXX1cXFxcbnt0YXNrLmRlc2NyaXB0aW9ufVxcXFxuXFxcXG5cIiArXHJcbiAgICAgICAgICAgIFwiUHJldmlvdXMgcmVsZXZhbnQgcmVzdWx0czpcXFxcblwiICtcclxuICAgICAgICAgICAgXCJcXFxcblwiLmpvaW4oW1xyXG4gICAgICAgICAgICAgICAgZlwiVGFzayB7ZGVwfToge3Jlc3VsdHNbZGVwXS5yZXN1bHR9XCJcclxuICAgICAgICAgICAgICAgIGZvciBkZXAgaW4gdGFzay5kZXBlbmRlbmNpZXNcclxuICAgICAgICAgICAgICAgIGlmIGRlcCBpbiByZXN1bHRzXHJcbiAgICAgICAgICAgIF0pLFxyXG4gICAgICAgICAgICBtb2RlbD1mXCJzcGVjaWFsaXplZC97dGFzay53b3JrZXJ9LWxsbVwiXHJcbiAgICAgICAgKVxyXG4gICAgICAgIFxyXG4gICAgICAgICMgU3RvcmUgcmVzdWx0XHJcbiAgICAgICAgcmVzdWx0c1tpXSA9IFdvcmtlclJlc3VsdChcclxuICAgICAgICAgICAgdGFza19pZD1pLFxyXG4gICAgICAgICAgICByZXN1bHQ9d29ya2VyX3Jlc3VsdCxcclxuICAgICAgICAgICAgc3RhdHVzPVwiY29tcGxldGVkXCJcclxuICAgICAgICApXHJcbiAgICBcclxuICAgICMgU3RlcCAzOiBPcmNoZXN0cmF0b3Igc3ludGhlc2l6ZXMgZmluYWwgcmVzdWx0XHJcbiAgICBTWU5USEVTSVNfUFJPTVBUID0gXCJcIlwiU3ludGhlc2l6ZSB0aGUgcmVzdWx0cyBvZiBhbGwgY29tcGxldGVkIHRhc2tzIGludG8gYSBcclxuICAgIGNvaGVyZW50IGZpbmFsIGRlbGl2ZXJhYmxlLiBFbnN1cmUgYWxsIGNvbXBvbmVudHMgd29yayB0b2dldGhlciBhbmQgbWVldCB0aGUgXHJcbiAgICBvcmlnaW5hbCBwcm9qZWN0IHJlcXVpcmVtZW50cy5cIlwiXCJcclxuICAgIFxyXG4gICAgZmluYWxfcmVzdWx0ID0gYXdhaXQgcnVuX2xsbShcclxuICAgICAgICBmXCJ7U1lOVEhFU0lTX1BST01QVH1cXFxcblxcXFxuUHJvamVjdCBSZXF1ZXN0OiB7cHJvamVjdF9yZXF1ZXN0fVxcXFxuXFxcXG5cIiArXHJcbiAgICAgICAgXCJUYXNrIFJlc3VsdHM6XFxcXG5cIiArXHJcbiAgICAgICAgXCJcXFxcblwiLmpvaW4oW1xyXG4gICAgICAgICAgICBmXCJUYXNrIHtpfToge3Jlc3VsdC5yZXN1bHR9XCJcclxuICAgICAgICAgICAgZm9yIGksIHJlc3VsdCBpbiByZXN1bHRzLml0ZW1zKClcclxuICAgICAgICBdKVxyXG4gICAgKVxyXG4gICAgXHJcbiAgICByZXR1cm4gZmluYWxfcmVzdWx0XHJcblxyXG4jIEV4YW1wbGUgdXNhZ2VcclxuYXN5bmMgZGVmIG1haW4oKTpcclxuICAgIHByb2plY3QgPSBcIlwiXCJcclxuICAgIENyZWF0ZSBhIHdlYiBhcHBsaWNhdGlvbiBmb3IgdGFzayBtYW5hZ2VtZW50IHdpdGggdGhlIGZvbGxvd2luZyByZXF1aXJlbWVudHM6XHJcbiAgICAxLiBVc2VyIGF1dGhlbnRpY2F0aW9uXHJcbiAgICAyLiBDUlVEIG9wZXJhdGlvbnMgZm9yIHRhc2tzXHJcbiAgICAzLiBUYXNrIGNhdGVnb3JpemF0aW9uIGFuZCBmaWx0ZXJpbmdcclxuICAgIDQuIFJlc3BvbnNpdmUgZGVzaWduXHJcbiAgICA1LiBEYXRhIHBlcnNpc3RlbmNlXHJcbiAgICBcIlwiXCJcclxuICAgIFxyXG4gICAgcmVzdWx0ID0gYXdhaXQgb3JjaGVzdHJhdG9yX3dvcmtmbG93KHByb2plY3QpXHJcbiAgICBwcmludChcIkZpbmFsIFByb2plY3QgRGVsaXZlcmFibGU6XFxcXG5cIiwgcmVzdWx0KVxyXG5cclxuaWYgX19uYW1lX18gPT0gXCJfX21haW5fX1wiOlxyXG4gICAgaW1wb3J0IGFzeW5jaW9cclxuICAgIGFzeW5jaW8ucnVuKG1haW4oKSlgLFxyXG4gIHR5cGVzY3JpcHRDb2RlOiBgaW1wb3J0IHsgTExNUmVzcG9uc2UgfSBmcm9tICcuL3R5cGVzJztcclxuaW1wb3J0IHsgcnVuTExNLCBKU09OTExNIH0gZnJvbSAnLi9oZWxwZXJzJztcclxuXHJcbmludGVyZmFjZSBUYXNrIHtcclxuICBkZXNjcmlwdGlvbjogc3RyaW5nO1xyXG4gIHdvcmtlcjogc3RyaW5nO1xyXG4gIHByaW9yaXR5OiBudW1iZXI7XHJcbiAgZGVwZW5kZW5jaWVzOiBudW1iZXJbXTtcclxufVxyXG5cclxuaW50ZXJmYWNlIFdvcmtlclJlc3VsdCB7XHJcbiAgdGFza19pZDogbnVtYmVyO1xyXG4gIHJlc3VsdDogc3RyaW5nO1xyXG4gIHN0YXR1czogc3RyaW5nO1xyXG59XHJcblxyXG5hc3luYyBmdW5jdGlvbiBvcmNoZXN0cmF0b3JXb3JrZmxvdyhwcm9qZWN0UmVxdWVzdDogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAvLyBTdGVwIDE6IE9yY2hlc3RyYXRvciBhbmFseXplcyBhbmQgYnJlYWtzIGRvd24gdGhlIHByb2plY3RcclxuICBjb25zdCBQTEFOTklOR19QUk9NUFQgPSBcXGBCcmVhayBkb3duIHRoaXMgcHJvamVjdCByZXF1ZXN0IGludG8gc3BlY2lmaWMgdGFza3MuXHJcbiAgRm9yIGVhY2ggdGFzayBzcGVjaWZ5OlxyXG4gIDEuIFRhc2sgZGVzY3JpcHRpb25cclxuICAyLiBXaGljaCB3b3JrZXIgc2hvdWxkIGhhbmRsZSBpdCAoY2hvb3NlIGZyb206IHJlc2VhcmNoZXIsIGFyY2hpdGVjdCwgZGV2ZWxvcGVyLCByZXZpZXdlcilcclxuICAzLiBQcmlvcml0eSAoMS01LCAxIGJlaW5nIGhpZ2hlc3QpXHJcbiAgNC4gRGVwZW5kZW5jaWVzICh0YXNrIElEcyB0aGF0IG11c3QgYmUgY29tcGxldGVkIGZpcnN0KVxyXG4gIFJldHVybiBhcyBKU09OIGFycmF5IG9mIHRhc2tzLlxcYDtcclxuXHJcbiAgY29uc3QgdGFza3MgPSBhd2FpdCBKU09OTExNPFRhc2tbXT4oXHJcbiAgICBcXGBcXCR7UExBTk5JTkdfUFJPTVBUfVxcXFxuUHJvamVjdDogXFwke3Byb2plY3RSZXF1ZXN0fVxcYFxyXG4gICk7XHJcblxyXG4gIC8vIFNvcnQgdGFza3MgYnkgcHJpb3JpdHkgYW5kIGRlcGVuZGVuY2llc1xyXG4gIHRhc2tzLnNvcnQoKGEsIGIpID0+IFxyXG4gICAgKGEuZGVwZW5kZW5jaWVzLmxlbmd0aCAtIGIuZGVwZW5kZW5jaWVzLmxlbmd0aCkgfHwgKGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KVxyXG4gICk7XHJcblxyXG4gIC8vIFN0ZXAgMjogRXhlY3V0ZSB0YXNrcyB0aHJvdWdoIHdvcmtlcnNcclxuICBjb25zdCByZXN1bHRzOiBSZWNvcmQ8bnVtYmVyLCBXb3JrZXJSZXN1bHQ+ID0ge307XHJcblxyXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGFza3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IHRhc2sgPSB0YXNrc1tpXTtcclxuXHJcbiAgICAvLyBXYWl0IGZvciBkZXBlbmRlbmNpZXMgdG8gY29tcGxldGVcclxuICAgIGNvbnN0IGRlcGVuZGVuY2llc0NvbXBsZXRlID0gdGFzay5kZXBlbmRlbmNpZXMuZXZlcnkoXHJcbiAgICAgIGRlcCA9PiBkZXAgaW4gcmVzdWx0cyAmJiByZXN1bHRzW2RlcF0uc3RhdHVzID09PSBcImNvbXBsZXRlZFwiXHJcbiAgICApO1xyXG4gICAgaWYgKCFkZXBlbmRlbmNpZXNDb21wbGV0ZSkgY29udGludWU7XHJcblxyXG4gICAgLy8gU2VsZWN0IGFwcHJvcHJpYXRlIHdvcmtlciBwcm9tcHQgYmFzZWQgb24gcm9sZVxyXG4gICAgY29uc3Qgd29ya2VyUHJvbXB0czogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHtcclxuICAgICAgcmVzZWFyY2hlcjogXCJSZXNlYXJjaCBhbmQgcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dDpcIixcclxuICAgICAgYXJjaGl0ZWN0OiBcIkRlc2lnbiB0aGUgYXJjaGl0ZWN0dXJlIGZvcjpcIixcclxuICAgICAgZGV2ZWxvcGVyOiBcIldyaXRlIGNvZGUgdG8gaW1wbGVtZW50OlwiLFxyXG4gICAgICByZXZpZXdlcjogXCJSZXZpZXcgYW5kIHByb3ZpZGUgZmVlZGJhY2sgb246XCJcclxuICAgIH07XHJcblxyXG4gICAgLy8gRXhlY3V0ZSB3b3JrZXIgdGFza1xyXG4gICAgY29uc3Qgd29ya2VyUmVzdWx0ID0gYXdhaXQgcnVuTExNKHtcclxuICAgICAgcHJvbXB0OiBcXGBcXCR7d29ya2VyUHJvbXB0c1t0YXNrLndvcmtlcl19XFxcXG5cXCR7dGFzay5kZXNjcmlwdGlvbn1cXFxcblxcXFxuXFxgICtcclxuICAgICAgICBcIlByZXZpb3VzIHJlbGV2YW50IHJlc3VsdHM6XFxcXG5cIiArXHJcbiAgICAgICAgdGFzay5kZXBlbmRlbmNpZXNcclxuICAgICAgICAgIC5maWx0ZXIoZGVwID0+IGRlcCBpbiByZXN1bHRzKVxyXG4gICAgICAgICAgLm1hcChkZXAgPT4gXFxgVGFzayBcXCR7ZGVwfTogXFwke3Jlc3VsdHNbZGVwXS5yZXN1bHR9XFxgKVxyXG4gICAgICAgICAgLmpvaW4oXCJcXFxcblwiKSxcclxuICAgICAgbW9kZWw6IFxcYHNwZWNpYWxpemVkL1xcJHt0YXNrLndvcmtlcn0tbGxtXFxgXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBTdG9yZSByZXN1bHRcclxuICAgIHJlc3VsdHNbaV0gPSB7XHJcbiAgICAgIHRhc2tfaWQ6IGksXHJcbiAgICAgIHJlc3VsdDogd29ya2VyUmVzdWx0LFxyXG4gICAgICBzdGF0dXM6IFwiY29tcGxldGVkXCJcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvLyBTdGVwIDM6IE9yY2hlc3RyYXRvciBzeW50aGVzaXplcyBmaW5hbCByZXN1bHRcclxuICBjb25zdCBTWU5USEVTSVNfUFJPTVBUID0gXFxgU3ludGhlc2l6ZSB0aGUgcmVzdWx0cyBvZiBhbGwgY29tcGxldGVkIHRhc2tzIGludG8gYSBcclxuICBjb2hlcmVudCBmaW5hbCBkZWxpdmVyYWJsZS4gRW5zdXJlIGFsbCBjb21wb25lbnRzIHdvcmsgdG9nZXRoZXIgYW5kIG1lZXQgdGhlIFxyXG4gIG9yaWdpbmFsIHByb2plY3QgcmVxdWlyZW1lbnRzLlxcYDtcclxuXHJcbiAgY29uc3QgZmluYWxSZXN1bHQgPSBhd2FpdCBydW5MTE0oe1xyXG4gICAgcHJvbXB0OiBcXGBcXCR7U1lOVEhFU0lTX1BST01QVH1cXFxcblxcXFxuUHJvamVjdCBSZXF1ZXN0OiBcXCR7cHJvamVjdFJlcXVlc3R9XFxcXG5cXFxcblxcYCArXHJcbiAgICAgIFwiVGFzayBSZXN1bHRzOlxcXFxuXCIgK1xyXG4gICAgICBPYmplY3QuZW50cmllcyhyZXN1bHRzKVxyXG4gICAgICAgIC5tYXAoKFtpLCByZXN1bHRdKSA9PiBcXGBUYXNrIFxcJHtpfTogXFwke3Jlc3VsdC5yZXN1bHR9XFxgKVxyXG4gICAgICAgIC5qb2luKFwiXFxcXG5cIilcclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIGZpbmFsUmVzdWx0O1xyXG59XHJcblxyXG4vLyBFeGFtcGxlIHVzYWdlXHJcbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgY29uc3QgcHJvamVjdCA9IFxcYFxyXG4gICAgQ3JlYXRlIGEgd2ViIGFwcGxpY2F0aW9uIGZvciB0YXNrIG1hbmFnZW1lbnQgd2l0aCB0aGUgZm9sbG93aW5nIHJlcXVpcmVtZW50czpcclxuICAgIDEuIFVzZXIgYXV0aGVudGljYXRpb25cclxuICAgIDIuIENSVUQgb3BlcmF0aW9ucyBmb3IgdGFza3NcclxuICAgIDMuIFRhc2sgY2F0ZWdvcml6YXRpb24gYW5kIGZpbHRlcmluZ1xyXG4gICAgNC4gUmVzcG9uc2l2ZSBkZXNpZ25cclxuICAgIDUuIERhdGEgcGVyc2lzdGVuY2VcclxuICBcXGA7XHJcblxyXG4gIGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9yY2hlc3RyYXRvcldvcmtmbG93KHByb2plY3QpO1xyXG4gIGNvbnNvbGUubG9nKFwiRmluYWwgUHJvamVjdCBEZWxpdmVyYWJsZTpcXFxcblwiLCByZXN1bHQpO1xyXG59XHJcblxyXG5tYWluKCkuY2F0Y2goY29uc29sZS5lcnJvcik7YFxyXG59O1xyXG4iXSwibmFtZXMiOlsib3JjaGVzdHJhdG9yV29ya2VycyIsInRpdGxlIiwidGFnIiwiZGVzY3JpcHRpb24iLCJleHBsYW5hdGlvbiIsInVzZUNhc2VzIiwicHl0aG9uQ29kZSIsInR5cGVzY3JpcHRDb2RlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/recipes/data/orchestrator-workers.ts\n"));

/***/ })

});