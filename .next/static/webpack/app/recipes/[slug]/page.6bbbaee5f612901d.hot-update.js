"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/recipes/[slug]/page",{

/***/ "(app-pages-browser)/./app/recipes/data/augmented-llm.ts":
/*!*******************************************!*\
  !*** ./app/recipes/data/augmented-llm.ts ***!
  \*******************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   augmentedLlm: function() { return /* binding */ augmentedLlm; }\n/* harmony export */ });\nconst augmentedLlm = {\n    title: \"Augmented LLM\",\n    tag: \"Architecture\",\n    description: \"An enhanced LLM architecture that extends the model's capabilities through integration with external retrieval systems, tools, and memory components.\",\n    explanation: \"The diagram shows how an LLM can be augmented with three key components: a retrieval system for accessing external knowledge, tools for performing specific actions, and a memory system for maintaining context. These components interact bidirectionally with the LLM, allowing it to query information, use tools, and maintain state across interactions.\",\n    useCases: [\n        \"Knowledge-Intensive Tasks: Augment LLM responses with real-time information from external sources.\",\n        \"Tool-Using Agents: Enable LLMs to interact with external tools and APIs to perform specific actions.\",\n        \"Stateful Applications: Maintain conversation history and context across multiple interactions.\"\n    ],\n    pythonCode: 'from typing import List, Dict, Any, Optional\\nfrom pydantic import BaseModel\\nfrom datetime import datetime\\nimport chromadb\\nfrom helpers import run_llm, JSON_llm, execute_tool\\n\\nclass Memory(BaseModel):\\n    \"\"\"Represents a memory entry\"\"\"\\n    timestamp: datetime\\n    content: str\\n    type: str\\n    metadata: Dict[str, Any]\\n\\nclass RetrievalResult(BaseModel):\\n    \"\"\"Represents a retrieval result\"\"\"\\n    content: str\\n    source: str\\n    relevance: float\\n\\nclass AugmentedLLM:\\n    def __init__(self):\\n        # Initialize components\\n        self.memory = []\\n        self.retrieval_client = chromadb.Client()\\n        self.tools = self._initialize_tools()\\n        \\n    def _initialize_tools(self) -> Dict[str, Any]:\\n        \"\"\"Initialize available tools\"\"\"\\n        return {\\n            \"calculator\": {\\n                \"description\": \"Perform mathematical calculations\",\\n                \"function\": self._calculate\\n            },\\n            \"web_search\": {\\n                \"description\": \"Search the web for information\",\\n                \"function\": self._search_web\\n            },\\n            \"database\": {\\n                \"description\": \"Query a database\",\\n                \"function\": self._query_database\\n            }\\n        }\\n    \\n    async def retrieve_relevant_info(\\n        self, \\n        query: str,\\n        k: int = 5\\n    ) -> List[RetrievalResult]:\\n        \"\"\"Retrieve relevant information from the knowledge base\"\"\"\\n        RETRIEVAL_PROMPT = \"\"\"Given this query, what specific information should we look for?\\n        Query: {query}\\n        \\n        Return as JSON with:\\n        - search_terms: list of relevant terms\\n        - filters: any filters to apply\\n        \"\"\"\\n        \\n        search_params = await JSON_llm(\\n            RETRIEVAL_PROMPT.format(query=query),\\n            dict\\n        )\\n        \\n        # Search vector database\\n        results = self.retrieval_client.query(\\n            query_texts=[query],\\n            n_results=k,\\n            where=search_params.get(\"filters\", {})\\n        )\\n        \\n        return [\\n            RetrievalResult(\\n                content=doc[\"content\"],\\n                source=doc[\"metadata\"][\"source\"],\\n                relevance=score\\n            )\\n            for doc, score in zip(results[\"documents\"], results[\"distances\"])\\n        ]\\n    \\n    async def determine_tool_needs(\\n        self,\\n        query: str,\\n        context: Dict[str, Any]\\n    ) -> List[Dict[str, Any]]:\\n        \"\"\"Determine which tools are needed\"\"\"\\n        TOOL_PROMPT = \"\"\"Given this query and context, what tools should be used?\\n        \\n        Query: {query}\\n        Context: {context}\\n        Available Tools: {tools}\\n        \\n        Return as JSON array of:\\n        - tool_name: name of tool to use\\n        - reason: why this tool is needed\\n        - parameters: parameters to pass to tool\\n        \"\"\"\\n        \\n        return await JSON_llm(\\n            TOOL_PROMPT.format(\\n                query=query,\\n                context=context,\\n                tools=self.tools\\n            ),\\n            List[Dict[str, Any]]\\n        )\\n    \\n    async def execute_tools(\\n        self,\\n        tool_calls: List[Dict[str, Any]]\\n    ) -> List[Any]:\\n        \"\"\"Execute required tools\"\"\"\\n        results = []\\n        for call in tool_calls:\\n            tool = self.tools[call[\"tool_name\"]]\\n            result = await tool[\"function\"](**call[\"parameters\"])\\n            results.append(result)\\n        return results\\n    \\n    def update_memory(\\n        self,\\n        content: str,\\n        memory_type: str,\\n        metadata: Dict[str, Any] = None\\n    ) -> None:\\n        \"\"\"Update system memory\"\"\"\\n        self.memory.append(Memory(\\n            timestamp=datetime.now(),\\n            content=content,\\n            type=memory_type,\\n            metadata=metadata or {}\\n        ))\\n    \\n    async def process_query(self, query: str) -> str:\\n        \"\"\"Process a query using augmented capabilities\"\"\"\\n        # Step 1: Retrieve relevant information\\n        relevant_info = await self.retrieve_relevant_info(query)\\n        \\n        # Step 2: Determine required tools\\n        context = {\\n            \"relevant_info\": relevant_info,\\n            \"recent_memory\": self.memory[-5:] if self.memory else []\\n        }\\n        tool_calls = await self.determine_tool_needs(query, context)\\n        \\n        # Step 3: Execute tools\\n        tool_results = await self.execute_tools(tool_calls)\\n        \\n        # Step 4: Generate response\\n        RESPONSE_PROMPT = \"\"\"Generate a response using all available information:\\n        \\n        Query: {query}\\n        Retrieved Information: {retrieved}\\n        Tool Results: {tool_results}\\n        Recent Memory: {memory}\\n        \\n        Synthesize this information into a comprehensive response.\"\"\"\\n        \\n        response = await run_llm(\\n            RESPONSE_PROMPT.format(\\n                query=query,\\n                retrieved=relevant_info,\\n                tool_results=tool_results,\\n                memory=self.memory[-5:]\\n            )\\n        )\\n        \\n        # Step 5: Update memory\\n        self.update_memory(\\n            content=response,\\n            memory_type=\"response\",\\n            metadata={\"query\": query}\\n        )\\n        \\n        return response\\n\\n# Example usage\\nasync def main():\\n    # Initialize augmented LLM\\n    llm = AugmentedLLM()\\n    \\n    # Process a complex query\\n    query = \"\"\"What was the impact of recent interest rate changes \\n    on tech company stock prices? Calculate the average percentage change \\n    and identify any significant outliers.\"\"\"\\n    \\n    response = await llm.process_query(query)\\n    print(\"Response:\", response)\\n\\nif __name__ == \"__main__\":\\n    import asyncio\\n    asyncio.run(main())',\n    typescriptCode: 'import { LLMResponse } from \\'./types\\';\\nimport { runLLM, JSONLLM, executeTool } from \\'./helpers\\';\\nimport { ChromaClient } from \\'chromadb\\';\\n\\ninterface Memory {\\n  timestamp: Date;\\n  content: string;\\n  type: string;\\n  metadata: Record<string, any>;\\n}\\n\\ninterface RetrievalResult {\\n  content: string;\\n  source: string;\\n  relevance: number;\\n}\\n\\ninterface Tool {\\n  description: string;\\n  function: (params: any) => Promise<any>;\\n}\\n\\nclass AugmentedLLM {\\n  private memory: Memory[] = [];\\n  private retrievalClient: ChromaClient;\\n  private tools: Record<string, Tool>;\\n\\n  constructor() {\\n    this.retrievalClient = new ChromaClient();\\n    this.tools = this.initializeTools();\\n  }\\n\\n  private initializeTools(): Record<string, Tool> {\\n    return {\\n      calculator: {\\n        description: \"Perform mathematical calculations\",\\n        function: this.calculate\\n      },\\n      web_search: {\\n        description: \"Search the web for information\",\\n        function: this.searchWeb\\n      },\\n      database: {\\n        description: \"Query a database\",\\n        function: this.queryDatabase\\n      }\\n    };\\n  }\\n\\n  async retrieveRelevantInfo(\\n    query: string,\\n    k: number = 5\\n  ): Promise<RetrievalResult[]> {\\n    const RETRIEVAL_PROMPT = `Given this query, what specific information should we look for?\\n    Query: ${query}\\n    \\n    Return as JSON with:\\n    - search_terms: list of relevant terms\\n    - filters: any filters to apply`;\\n\\n    const searchParams = await JSONLLM<{\\n      search_terms: string[];\\n      filters: Record<string, any>;\\n    }>(RETRIEVAL_PROMPT);\\n\\n    // Search vector database\\n    const results = await this.retrievalClient.query({\\n      queryTexts: [query],\\n      nResults: k,\\n      where: searchParams.filters\\n    });\\n\\n    return results.documents[0].map((doc: any, i: number) => ({\\n      content: doc.content,\\n      source: doc.metadata.source,\\n      relevance: results.distances[0][i]\\n    }));\\n  }\\n\\n  async determineToolNeeds(\\n    query: string,\\n    context: Record<string, any>\\n  ): Promise<Array<{\\n    tool_name: string;\\n    reason: string;\\n    parameters: Record<string, any>;\\n  }>> {\\n    const TOOL_PROMPT = `Given this query and context, what tools should be used?\\n    \\n    Query: ${query}\\n    Context: ${JSON.stringify(context)}\\n    Available Tools: ${JSON.stringify(this.tools)}\\n    \\n    Return as JSON array of:\\n    - tool_name: name of tool to use\\n    - reason: why this tool is needed\\n    - parameters: parameters to pass to tool`;\\n\\n    return await JSONLLM(TOOL_PROMPT);\\n  }\\n\\n  async executeTools(\\n    toolCalls: Array<{\\n      tool_name: string;\\n      parameters: Record<string, any>;\\n    }>\\n  ): Promise<any[]> {\\n    return await Promise.all(\\n      toolCalls.map(call => \\n        this.tools[call.tool_name].function(call.parameters)\\n      )\\n    );\\n  }\\n\\n  private updateMemory(\\n    content: string,\\n    memoryType: string,\\n    metadata: Record<string, any> = {}\\n  ): void {\\n    this.memory.push({\\n      timestamp: new Date(),\\n      content,\\n      type: memoryType,\\n      metadata\\n    });\\n  }\\n\\n  async processQuery(query: string): Promise<string> {\\n    // Step 1: Retrieve relevant information\\n    const relevantInfo = await this.retrieveRelevantInfo(query);\\n\\n    // Step 2: Determine required tools\\n    const context = {\\n      relevant_info: relevantInfo,\\n      recent_memory: this.memory.slice(-5)\\n    };\\n    const toolCalls = await this.determineToolNeeds(query, context);\\n\\n    // Step 3: Execute tools\\n    const toolResults = await this.executeTools(toolCalls);\\n\\n    // Step 4: Generate response\\n    const RESPONSE_PROMPT = `Generate a response using all available information:\\n    \\n    Query: ${query}\\n    Retrieved Information: ${JSON.stringify(relevantInfo)}\\n    Tool Results: ${JSON.stringify(toolResults)}\\n    Recent Memory: ${JSON.stringify(this.memory.slice(-5))}\\n    \\n    Synthesize this information into a comprehensive response.`;\\n\\n    const response = await runLLM(RESPONSE_PROMPT);\\n\\n    // Step 5: Update memory\\n    this.updateMemory(response, \"response\", { query });\\n\\n    return response;\\n  }\\n\\n  private async calculate(params: any): Promise<number> {\\n    // Implementation of calculator tool\\n    return 0;\\n  }\\n\\n  private async searchWeb(params: any): Promise<any> {\\n    // Implementation of web search tool\\n    return null;\\n  }\\n\\n  private async queryDatabase(params: any): Promise<any> {\\n    // Implementation of database query tool\\n    return null;\\n  }\\n}\\n\\n// Example usage\\nasync function main() {\\n  // Initialize augmented LLM\\n  const llm = new AugmentedLLM();\\n\\n  // Process a complex query\\n  const query = `What was the impact of recent interest rate changes \\n  on tech company stock prices? Calculate the average percentage change \\n  and identify any significant outliers.`;\\n\\n  const response = await llm.processQuery(query);\\n  console.log(\"Response:\", response);\\n}\\n\\nmain().catch(console.error);'\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9yZWNpcGVzL2RhdGEvYXVnbWVudGVkLWxsbS50cyIsIm1hcHBpbmdzIjoiOzs7O0FBRU8sTUFBTUEsZUFBdUI7SUFDbENDLE9BQU87SUFDUEMsS0FBSztJQUNMQyxhQUFhO0lBQ2JDLGFBQWE7SUFDYkMsVUFBVTtRQUNSO1FBQ0E7UUFDQTtLQUNEO0lBQ0RDLFlBQWE7SUE4TGJDLGdCQUFpQjtBQThMbkIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvcmVjaXBlcy9kYXRhL2F1Z21lbnRlZC1sbG0udHM/ZDIzNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSZWNpcGUgfSBmcm9tICcuL2luZGV4JztcclxuXHJcbmV4cG9ydCBjb25zdCBhdWdtZW50ZWRMbG06IFJlY2lwZSA9IHtcclxuICB0aXRsZTogXCJBdWdtZW50ZWQgTExNXCIsXHJcbiAgdGFnOiBcIkFyY2hpdGVjdHVyZVwiLFxyXG4gIGRlc2NyaXB0aW9uOiBcIkFuIGVuaGFuY2VkIExMTSBhcmNoaXRlY3R1cmUgdGhhdCBleHRlbmRzIHRoZSBtb2RlbCdzIGNhcGFiaWxpdGllcyB0aHJvdWdoIGludGVncmF0aW9uIHdpdGggZXh0ZXJuYWwgcmV0cmlldmFsIHN5c3RlbXMsIHRvb2xzLCBhbmQgbWVtb3J5IGNvbXBvbmVudHMuXCIsXHJcbiAgZXhwbGFuYXRpb246IFwiVGhlIGRpYWdyYW0gc2hvd3MgaG93IGFuIExMTSBjYW4gYmUgYXVnbWVudGVkIHdpdGggdGhyZWUga2V5IGNvbXBvbmVudHM6IGEgcmV0cmlldmFsIHN5c3RlbSBmb3IgYWNjZXNzaW5nIGV4dGVybmFsIGtub3dsZWRnZSwgdG9vbHMgZm9yIHBlcmZvcm1pbmcgc3BlY2lmaWMgYWN0aW9ucywgYW5kIGEgbWVtb3J5IHN5c3RlbSBmb3IgbWFpbnRhaW5pbmcgY29udGV4dC4gVGhlc2UgY29tcG9uZW50cyBpbnRlcmFjdCBiaWRpcmVjdGlvbmFsbHkgd2l0aCB0aGUgTExNLCBhbGxvd2luZyBpdCB0byBxdWVyeSBpbmZvcm1hdGlvbiwgdXNlIHRvb2xzLCBhbmQgbWFpbnRhaW4gc3RhdGUgYWNyb3NzIGludGVyYWN0aW9ucy5cIixcclxuICB1c2VDYXNlczogW1xyXG4gICAgXCJLbm93bGVkZ2UtSW50ZW5zaXZlIFRhc2tzOiBBdWdtZW50IExMTSByZXNwb25zZXMgd2l0aCByZWFsLXRpbWUgaW5mb3JtYXRpb24gZnJvbSBleHRlcm5hbCBzb3VyY2VzLlwiLFxyXG4gICAgXCJUb29sLVVzaW5nIEFnZW50czogRW5hYmxlIExMTXMgdG8gaW50ZXJhY3Qgd2l0aCBleHRlcm5hbCB0b29scyBhbmQgQVBJcyB0byBwZXJmb3JtIHNwZWNpZmljIGFjdGlvbnMuXCIsXHJcbiAgICBcIlN0YXRlZnVsIEFwcGxpY2F0aW9uczogTWFpbnRhaW4gY29udmVyc2F0aW9uIGhpc3RvcnkgYW5kIGNvbnRleHQgYWNyb3NzIG11bHRpcGxlIGludGVyYWN0aW9ucy5cIlxyXG4gIF0sXHJcbiAgcHl0aG9uQ29kZTogYGZyb20gdHlwaW5nIGltcG9ydCBMaXN0LCBEaWN0LCBBbnksIE9wdGlvbmFsXHJcbmZyb20gcHlkYW50aWMgaW1wb3J0IEJhc2VNb2RlbFxyXG5mcm9tIGRhdGV0aW1lIGltcG9ydCBkYXRldGltZVxyXG5pbXBvcnQgY2hyb21hZGJcclxuZnJvbSBoZWxwZXJzIGltcG9ydCBydW5fbGxtLCBKU09OX2xsbSwgZXhlY3V0ZV90b29sXHJcblxyXG5jbGFzcyBNZW1vcnkoQmFzZU1vZGVsKTpcclxuICAgIFwiXCJcIlJlcHJlc2VudHMgYSBtZW1vcnkgZW50cnlcIlwiXCJcclxuICAgIHRpbWVzdGFtcDogZGF0ZXRpbWVcclxuICAgIGNvbnRlbnQ6IHN0clxyXG4gICAgdHlwZTogc3RyXHJcbiAgICBtZXRhZGF0YTogRGljdFtzdHIsIEFueV1cclxuXHJcbmNsYXNzIFJldHJpZXZhbFJlc3VsdChCYXNlTW9kZWwpOlxyXG4gICAgXCJcIlwiUmVwcmVzZW50cyBhIHJldHJpZXZhbCByZXN1bHRcIlwiXCJcclxuICAgIGNvbnRlbnQ6IHN0clxyXG4gICAgc291cmNlOiBzdHJcclxuICAgIHJlbGV2YW5jZTogZmxvYXRcclxuXHJcbmNsYXNzIEF1Z21lbnRlZExMTTpcclxuICAgIGRlZiBfX2luaXRfXyhzZWxmKTpcclxuICAgICAgICAjIEluaXRpYWxpemUgY29tcG9uZW50c1xyXG4gICAgICAgIHNlbGYubWVtb3J5ID0gW11cclxuICAgICAgICBzZWxmLnJldHJpZXZhbF9jbGllbnQgPSBjaHJvbWFkYi5DbGllbnQoKVxyXG4gICAgICAgIHNlbGYudG9vbHMgPSBzZWxmLl9pbml0aWFsaXplX3Rvb2xzKClcclxuICAgICAgICBcclxuICAgIGRlZiBfaW5pdGlhbGl6ZV90b29scyhzZWxmKSAtPiBEaWN0W3N0ciwgQW55XTpcclxuICAgICAgICBcIlwiXCJJbml0aWFsaXplIGF2YWlsYWJsZSB0b29sc1wiXCJcIlxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIFwiY2FsY3VsYXRvclwiOiB7XHJcbiAgICAgICAgICAgICAgICBcImRlc2NyaXB0aW9uXCI6IFwiUGVyZm9ybSBtYXRoZW1hdGljYWwgY2FsY3VsYXRpb25zXCIsXHJcbiAgICAgICAgICAgICAgICBcImZ1bmN0aW9uXCI6IHNlbGYuX2NhbGN1bGF0ZVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBcIndlYl9zZWFyY2hcIjoge1xyXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlNlYXJjaCB0aGUgd2ViIGZvciBpbmZvcm1hdGlvblwiLFxyXG4gICAgICAgICAgICAgICAgXCJmdW5jdGlvblwiOiBzZWxmLl9zZWFyY2hfd2ViXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIFwiZGF0YWJhc2VcIjoge1xyXG4gICAgICAgICAgICAgICAgXCJkZXNjcmlwdGlvblwiOiBcIlF1ZXJ5IGEgZGF0YWJhc2VcIixcclxuICAgICAgICAgICAgICAgIFwiZnVuY3Rpb25cIjogc2VsZi5fcXVlcnlfZGF0YWJhc2VcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIFxyXG4gICAgYXN5bmMgZGVmIHJldHJpZXZlX3JlbGV2YW50X2luZm8oXHJcbiAgICAgICAgc2VsZiwgXHJcbiAgICAgICAgcXVlcnk6IHN0cixcclxuICAgICAgICBrOiBpbnQgPSA1XHJcbiAgICApIC0+IExpc3RbUmV0cmlldmFsUmVzdWx0XTpcclxuICAgICAgICBcIlwiXCJSZXRyaWV2ZSByZWxldmFudCBpbmZvcm1hdGlvbiBmcm9tIHRoZSBrbm93bGVkZ2UgYmFzZVwiXCJcIlxyXG4gICAgICAgIFJFVFJJRVZBTF9QUk9NUFQgPSBcIlwiXCJHaXZlbiB0aGlzIHF1ZXJ5LCB3aGF0IHNwZWNpZmljIGluZm9ybWF0aW9uIHNob3VsZCB3ZSBsb29rIGZvcj9cclxuICAgICAgICBRdWVyeToge3F1ZXJ5fVxyXG4gICAgICAgIFxyXG4gICAgICAgIFJldHVybiBhcyBKU09OIHdpdGg6XHJcbiAgICAgICAgLSBzZWFyY2hfdGVybXM6IGxpc3Qgb2YgcmVsZXZhbnQgdGVybXNcclxuICAgICAgICAtIGZpbHRlcnM6IGFueSBmaWx0ZXJzIHRvIGFwcGx5XHJcbiAgICAgICAgXCJcIlwiXHJcbiAgICAgICAgXHJcbiAgICAgICAgc2VhcmNoX3BhcmFtcyA9IGF3YWl0IEpTT05fbGxtKFxyXG4gICAgICAgICAgICBSRVRSSUVWQUxfUFJPTVBULmZvcm1hdChxdWVyeT1xdWVyeSksXHJcbiAgICAgICAgICAgIGRpY3RcclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICAgICAgIyBTZWFyY2ggdmVjdG9yIGRhdGFiYXNlXHJcbiAgICAgICAgcmVzdWx0cyA9IHNlbGYucmV0cmlldmFsX2NsaWVudC5xdWVyeShcclxuICAgICAgICAgICAgcXVlcnlfdGV4dHM9W3F1ZXJ5XSxcclxuICAgICAgICAgICAgbl9yZXN1bHRzPWssXHJcbiAgICAgICAgICAgIHdoZXJlPXNlYXJjaF9wYXJhbXMuZ2V0KFwiZmlsdGVyc1wiLCB7fSlcclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIFtcclxuICAgICAgICAgICAgUmV0cmlldmFsUmVzdWx0KFxyXG4gICAgICAgICAgICAgICAgY29udGVudD1kb2NbXCJjb250ZW50XCJdLFxyXG4gICAgICAgICAgICAgICAgc291cmNlPWRvY1tcIm1ldGFkYXRhXCJdW1wic291cmNlXCJdLFxyXG4gICAgICAgICAgICAgICAgcmVsZXZhbmNlPXNjb3JlXHJcbiAgICAgICAgICAgIClcclxuICAgICAgICAgICAgZm9yIGRvYywgc2NvcmUgaW4gemlwKHJlc3VsdHNbXCJkb2N1bWVudHNcIl0sIHJlc3VsdHNbXCJkaXN0YW5jZXNcIl0pXHJcbiAgICAgICAgXVxyXG4gICAgXHJcbiAgICBhc3luYyBkZWYgZGV0ZXJtaW5lX3Rvb2xfbmVlZHMoXHJcbiAgICAgICAgc2VsZixcclxuICAgICAgICBxdWVyeTogc3RyLFxyXG4gICAgICAgIGNvbnRleHQ6IERpY3Rbc3RyLCBBbnldXHJcbiAgICApIC0+IExpc3RbRGljdFtzdHIsIEFueV1dOlxyXG4gICAgICAgIFwiXCJcIkRldGVybWluZSB3aGljaCB0b29scyBhcmUgbmVlZGVkXCJcIlwiXHJcbiAgICAgICAgVE9PTF9QUk9NUFQgPSBcIlwiXCJHaXZlbiB0aGlzIHF1ZXJ5IGFuZCBjb250ZXh0LCB3aGF0IHRvb2xzIHNob3VsZCBiZSB1c2VkP1xyXG4gICAgICAgIFxyXG4gICAgICAgIFF1ZXJ5OiB7cXVlcnl9XHJcbiAgICAgICAgQ29udGV4dDoge2NvbnRleHR9XHJcbiAgICAgICAgQXZhaWxhYmxlIFRvb2xzOiB7dG9vbHN9XHJcbiAgICAgICAgXHJcbiAgICAgICAgUmV0dXJuIGFzIEpTT04gYXJyYXkgb2Y6XHJcbiAgICAgICAgLSB0b29sX25hbWU6IG5hbWUgb2YgdG9vbCB0byB1c2VcclxuICAgICAgICAtIHJlYXNvbjogd2h5IHRoaXMgdG9vbCBpcyBuZWVkZWRcclxuICAgICAgICAtIHBhcmFtZXRlcnM6IHBhcmFtZXRlcnMgdG8gcGFzcyB0byB0b29sXHJcbiAgICAgICAgXCJcIlwiXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIGF3YWl0IEpTT05fbGxtKFxyXG4gICAgICAgICAgICBUT09MX1BST01QVC5mb3JtYXQoXHJcbiAgICAgICAgICAgICAgICBxdWVyeT1xdWVyeSxcclxuICAgICAgICAgICAgICAgIGNvbnRleHQ9Y29udGV4dCxcclxuICAgICAgICAgICAgICAgIHRvb2xzPXNlbGYudG9vbHNcclxuICAgICAgICAgICAgKSxcclxuICAgICAgICAgICAgTGlzdFtEaWN0W3N0ciwgQW55XV1cclxuICAgICAgICApXHJcbiAgICBcclxuICAgIGFzeW5jIGRlZiBleGVjdXRlX3Rvb2xzKFxyXG4gICAgICAgIHNlbGYsXHJcbiAgICAgICAgdG9vbF9jYWxsczogTGlzdFtEaWN0W3N0ciwgQW55XV1cclxuICAgICkgLT4gTGlzdFtBbnldOlxyXG4gICAgICAgIFwiXCJcIkV4ZWN1dGUgcmVxdWlyZWQgdG9vbHNcIlwiXCJcclxuICAgICAgICByZXN1bHRzID0gW11cclxuICAgICAgICBmb3IgY2FsbCBpbiB0b29sX2NhbGxzOlxyXG4gICAgICAgICAgICB0b29sID0gc2VsZi50b29sc1tjYWxsW1widG9vbF9uYW1lXCJdXVxyXG4gICAgICAgICAgICByZXN1bHQgPSBhd2FpdCB0b29sW1wiZnVuY3Rpb25cIl0oKipjYWxsW1wicGFyYW1ldGVyc1wiXSlcclxuICAgICAgICAgICAgcmVzdWx0cy5hcHBlbmQocmVzdWx0KVxyXG4gICAgICAgIHJldHVybiByZXN1bHRzXHJcbiAgICBcclxuICAgIGRlZiB1cGRhdGVfbWVtb3J5KFxyXG4gICAgICAgIHNlbGYsXHJcbiAgICAgICAgY29udGVudDogc3RyLFxyXG4gICAgICAgIG1lbW9yeV90eXBlOiBzdHIsXHJcbiAgICAgICAgbWV0YWRhdGE6IERpY3Rbc3RyLCBBbnldID0gTm9uZVxyXG4gICAgKSAtPiBOb25lOlxyXG4gICAgICAgIFwiXCJcIlVwZGF0ZSBzeXN0ZW0gbWVtb3J5XCJcIlwiXHJcbiAgICAgICAgc2VsZi5tZW1vcnkuYXBwZW5kKE1lbW9yeShcclxuICAgICAgICAgICAgdGltZXN0YW1wPWRhdGV0aW1lLm5vdygpLFxyXG4gICAgICAgICAgICBjb250ZW50PWNvbnRlbnQsXHJcbiAgICAgICAgICAgIHR5cGU9bWVtb3J5X3R5cGUsXHJcbiAgICAgICAgICAgIG1ldGFkYXRhPW1ldGFkYXRhIG9yIHt9XHJcbiAgICAgICAgKSlcclxuICAgIFxyXG4gICAgYXN5bmMgZGVmIHByb2Nlc3NfcXVlcnkoc2VsZiwgcXVlcnk6IHN0cikgLT4gc3RyOlxyXG4gICAgICAgIFwiXCJcIlByb2Nlc3MgYSBxdWVyeSB1c2luZyBhdWdtZW50ZWQgY2FwYWJpbGl0aWVzXCJcIlwiXHJcbiAgICAgICAgIyBTdGVwIDE6IFJldHJpZXZlIHJlbGV2YW50IGluZm9ybWF0aW9uXHJcbiAgICAgICAgcmVsZXZhbnRfaW5mbyA9IGF3YWl0IHNlbGYucmV0cmlldmVfcmVsZXZhbnRfaW5mbyhxdWVyeSlcclxuICAgICAgICBcclxuICAgICAgICAjIFN0ZXAgMjogRGV0ZXJtaW5lIHJlcXVpcmVkIHRvb2xzXHJcbiAgICAgICAgY29udGV4dCA9IHtcclxuICAgICAgICAgICAgXCJyZWxldmFudF9pbmZvXCI6IHJlbGV2YW50X2luZm8sXHJcbiAgICAgICAgICAgIFwicmVjZW50X21lbW9yeVwiOiBzZWxmLm1lbW9yeVstNTpdIGlmIHNlbGYubWVtb3J5IGVsc2UgW11cclxuICAgICAgICB9XHJcbiAgICAgICAgdG9vbF9jYWxscyA9IGF3YWl0IHNlbGYuZGV0ZXJtaW5lX3Rvb2xfbmVlZHMocXVlcnksIGNvbnRleHQpXHJcbiAgICAgICAgXHJcbiAgICAgICAgIyBTdGVwIDM6IEV4ZWN1dGUgdG9vbHNcclxuICAgICAgICB0b29sX3Jlc3VsdHMgPSBhd2FpdCBzZWxmLmV4ZWN1dGVfdG9vbHModG9vbF9jYWxscylcclxuICAgICAgICBcclxuICAgICAgICAjIFN0ZXAgNDogR2VuZXJhdGUgcmVzcG9uc2VcclxuICAgICAgICBSRVNQT05TRV9QUk9NUFQgPSBcIlwiXCJHZW5lcmF0ZSBhIHJlc3BvbnNlIHVzaW5nIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb246XHJcbiAgICAgICAgXHJcbiAgICAgICAgUXVlcnk6IHtxdWVyeX1cclxuICAgICAgICBSZXRyaWV2ZWQgSW5mb3JtYXRpb246IHtyZXRyaWV2ZWR9XHJcbiAgICAgICAgVG9vbCBSZXN1bHRzOiB7dG9vbF9yZXN1bHRzfVxyXG4gICAgICAgIFJlY2VudCBNZW1vcnk6IHttZW1vcnl9XHJcbiAgICAgICAgXHJcbiAgICAgICAgU3ludGhlc2l6ZSB0aGlzIGluZm9ybWF0aW9uIGludG8gYSBjb21wcmVoZW5zaXZlIHJlc3BvbnNlLlwiXCJcIlxyXG4gICAgICAgIFxyXG4gICAgICAgIHJlc3BvbnNlID0gYXdhaXQgcnVuX2xsbShcclxuICAgICAgICAgICAgUkVTUE9OU0VfUFJPTVBULmZvcm1hdChcclxuICAgICAgICAgICAgICAgIHF1ZXJ5PXF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgcmV0cmlldmVkPXJlbGV2YW50X2luZm8sXHJcbiAgICAgICAgICAgICAgICB0b29sX3Jlc3VsdHM9dG9vbF9yZXN1bHRzLFxyXG4gICAgICAgICAgICAgICAgbWVtb3J5PXNlbGYubWVtb3J5Wy01Ol1cclxuICAgICAgICAgICAgKVxyXG4gICAgICAgIClcclxuICAgICAgICBcclxuICAgICAgICAjIFN0ZXAgNTogVXBkYXRlIG1lbW9yeVxyXG4gICAgICAgIHNlbGYudXBkYXRlX21lbW9yeShcclxuICAgICAgICAgICAgY29udGVudD1yZXNwb25zZSxcclxuICAgICAgICAgICAgbWVtb3J5X3R5cGU9XCJyZXNwb25zZVwiLFxyXG4gICAgICAgICAgICBtZXRhZGF0YT17XCJxdWVyeVwiOiBxdWVyeX1cclxuICAgICAgICApXHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlXHJcblxyXG4jIEV4YW1wbGUgdXNhZ2VcclxuYXN5bmMgZGVmIG1haW4oKTpcclxuICAgICMgSW5pdGlhbGl6ZSBhdWdtZW50ZWQgTExNXHJcbiAgICBsbG0gPSBBdWdtZW50ZWRMTE0oKVxyXG4gICAgXHJcbiAgICAjIFByb2Nlc3MgYSBjb21wbGV4IHF1ZXJ5XHJcbiAgICBxdWVyeSA9IFwiXCJcIldoYXQgd2FzIHRoZSBpbXBhY3Qgb2YgcmVjZW50IGludGVyZXN0IHJhdGUgY2hhbmdlcyBcclxuICAgIG9uIHRlY2ggY29tcGFueSBzdG9jayBwcmljZXM/IENhbGN1bGF0ZSB0aGUgYXZlcmFnZSBwZXJjZW50YWdlIGNoYW5nZSBcclxuICAgIGFuZCBpZGVudGlmeSBhbnkgc2lnbmlmaWNhbnQgb3V0bGllcnMuXCJcIlwiXHJcbiAgICBcclxuICAgIHJlc3BvbnNlID0gYXdhaXQgbGxtLnByb2Nlc3NfcXVlcnkocXVlcnkpXHJcbiAgICBwcmludChcIlJlc3BvbnNlOlwiLCByZXNwb25zZSlcclxuXHJcbmlmIF9fbmFtZV9fID09IFwiX19tYWluX19cIjpcclxuICAgIGltcG9ydCBhc3luY2lvXHJcbiAgICBhc3luY2lvLnJ1bihtYWluKCkpYCxcclxuICB0eXBlc2NyaXB0Q29kZTogYGltcG9ydCB7IExMTVJlc3BvbnNlIH0gZnJvbSAnLi90eXBlcyc7XHJcbmltcG9ydCB7IHJ1bkxMTSwgSlNPTkxMTSwgZXhlY3V0ZVRvb2wgfSBmcm9tICcuL2hlbHBlcnMnO1xyXG5pbXBvcnQgeyBDaHJvbWFDbGllbnQgfSBmcm9tICdjaHJvbWFkYic7XHJcblxyXG5pbnRlcmZhY2UgTWVtb3J5IHtcclxuICB0aW1lc3RhbXA6IERhdGU7XHJcbiAgY29udGVudDogc3RyaW5nO1xyXG4gIHR5cGU6IHN0cmluZztcclxuICBtZXRhZGF0YTogUmVjb3JkPHN0cmluZywgYW55PjtcclxufVxyXG5cclxuaW50ZXJmYWNlIFJldHJpZXZhbFJlc3VsdCB7XHJcbiAgY29udGVudDogc3RyaW5nO1xyXG4gIHNvdXJjZTogc3RyaW5nO1xyXG4gIHJlbGV2YW5jZTogbnVtYmVyO1xyXG59XHJcblxyXG5pbnRlcmZhY2UgVG9vbCB7XHJcbiAgZGVzY3JpcHRpb246IHN0cmluZztcclxuICBmdW5jdGlvbjogKHBhcmFtczogYW55KSA9PiBQcm9taXNlPGFueT47XHJcbn1cclxuXHJcbmNsYXNzIEF1Z21lbnRlZExMTSB7XHJcbiAgcHJpdmF0ZSBtZW1vcnk6IE1lbW9yeVtdID0gW107XHJcbiAgcHJpdmF0ZSByZXRyaWV2YWxDbGllbnQ6IENocm9tYUNsaWVudDtcclxuICBwcml2YXRlIHRvb2xzOiBSZWNvcmQ8c3RyaW5nLCBUb29sPjtcclxuXHJcbiAgY29uc3RydWN0b3IoKSB7XHJcbiAgICB0aGlzLnJldHJpZXZhbENsaWVudCA9IG5ldyBDaHJvbWFDbGllbnQoKTtcclxuICAgIHRoaXMudG9vbHMgPSB0aGlzLmluaXRpYWxpemVUb29scygpO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBpbml0aWFsaXplVG9vbHMoKTogUmVjb3JkPHN0cmluZywgVG9vbD4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgY2FsY3VsYXRvcjoge1xyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBcIlBlcmZvcm0gbWF0aGVtYXRpY2FsIGNhbGN1bGF0aW9uc1wiLFxyXG4gICAgICAgIGZ1bmN0aW9uOiB0aGlzLmNhbGN1bGF0ZVxyXG4gICAgICB9LFxyXG4gICAgICB3ZWJfc2VhcmNoOiB7XHJcbiAgICAgICAgZGVzY3JpcHRpb246IFwiU2VhcmNoIHRoZSB3ZWIgZm9yIGluZm9ybWF0aW9uXCIsXHJcbiAgICAgICAgZnVuY3Rpb246IHRoaXMuc2VhcmNoV2ViXHJcbiAgICAgIH0sXHJcbiAgICAgIGRhdGFiYXNlOiB7XHJcbiAgICAgICAgZGVzY3JpcHRpb246IFwiUXVlcnkgYSBkYXRhYmFzZVwiLFxyXG4gICAgICAgIGZ1bmN0aW9uOiB0aGlzLnF1ZXJ5RGF0YWJhc2VcclxuICAgICAgfVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHJldHJpZXZlUmVsZXZhbnRJbmZvKFxyXG4gICAgcXVlcnk6IHN0cmluZyxcclxuICAgIGs6IG51bWJlciA9IDVcclxuICApOiBQcm9taXNlPFJldHJpZXZhbFJlc3VsdFtdPiB7XHJcbiAgICBjb25zdCBSRVRSSUVWQUxfUFJPTVBUID0gXFxgR2l2ZW4gdGhpcyBxdWVyeSwgd2hhdCBzcGVjaWZpYyBpbmZvcm1hdGlvbiBzaG91bGQgd2UgbG9vayBmb3I/XHJcbiAgICBRdWVyeTogXFwke3F1ZXJ5fVxyXG4gICAgXHJcbiAgICBSZXR1cm4gYXMgSlNPTiB3aXRoOlxyXG4gICAgLSBzZWFyY2hfdGVybXM6IGxpc3Qgb2YgcmVsZXZhbnQgdGVybXNcclxuICAgIC0gZmlsdGVyczogYW55IGZpbHRlcnMgdG8gYXBwbHlcXGA7XHJcblxyXG4gICAgY29uc3Qgc2VhcmNoUGFyYW1zID0gYXdhaXQgSlNPTkxMTTx7XHJcbiAgICAgIHNlYXJjaF90ZXJtczogc3RyaW5nW107XHJcbiAgICAgIGZpbHRlcnM6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbiAgICB9PihSRVRSSUVWQUxfUFJPTVBUKTtcclxuXHJcbiAgICAvLyBTZWFyY2ggdmVjdG9yIGRhdGFiYXNlXHJcbiAgICBjb25zdCByZXN1bHRzID0gYXdhaXQgdGhpcy5yZXRyaWV2YWxDbGllbnQucXVlcnkoe1xyXG4gICAgICBxdWVyeVRleHRzOiBbcXVlcnldLFxyXG4gICAgICBuUmVzdWx0czogayxcclxuICAgICAgd2hlcmU6IHNlYXJjaFBhcmFtcy5maWx0ZXJzXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0cy5kb2N1bWVudHNbMF0ubWFwKChkb2M6IGFueSwgaTogbnVtYmVyKSA9PiAoe1xyXG4gICAgICBjb250ZW50OiBkb2MuY29udGVudCxcclxuICAgICAgc291cmNlOiBkb2MubWV0YWRhdGEuc291cmNlLFxyXG4gICAgICByZWxldmFuY2U6IHJlc3VsdHMuZGlzdGFuY2VzWzBdW2ldXHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBkZXRlcm1pbmVUb29sTmVlZHMoXHJcbiAgICBxdWVyeTogc3RyaW5nLFxyXG4gICAgY29udGV4dDogUmVjb3JkPHN0cmluZywgYW55PlxyXG4gICk6IFByb21pc2U8QXJyYXk8e1xyXG4gICAgdG9vbF9uYW1lOiBzdHJpbmc7XHJcbiAgICByZWFzb246IHN0cmluZztcclxuICAgIHBhcmFtZXRlcnM6IFJlY29yZDxzdHJpbmcsIGFueT47XHJcbiAgfT4+IHtcclxuICAgIGNvbnN0IFRPT0xfUFJPTVBUID0gXFxgR2l2ZW4gdGhpcyBxdWVyeSBhbmQgY29udGV4dCwgd2hhdCB0b29scyBzaG91bGQgYmUgdXNlZD9cclxuICAgIFxyXG4gICAgUXVlcnk6IFxcJHtxdWVyeX1cclxuICAgIENvbnRleHQ6IFxcJHtKU09OLnN0cmluZ2lmeShjb250ZXh0KX1cclxuICAgIEF2YWlsYWJsZSBUb29sczogXFwke0pTT04uc3RyaW5naWZ5KHRoaXMudG9vbHMpfVxyXG4gICAgXHJcbiAgICBSZXR1cm4gYXMgSlNPTiBhcnJheSBvZjpcclxuICAgIC0gdG9vbF9uYW1lOiBuYW1lIG9mIHRvb2wgdG8gdXNlXHJcbiAgICAtIHJlYXNvbjogd2h5IHRoaXMgdG9vbCBpcyBuZWVkZWRcclxuICAgIC0gcGFyYW1ldGVyczogcGFyYW1ldGVycyB0byBwYXNzIHRvIHRvb2xcXGA7XHJcblxyXG4gICAgcmV0dXJuIGF3YWl0IEpTT05MTE0oVE9PTF9QUk9NUFQpO1xyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXhlY3V0ZVRvb2xzKFxyXG4gICAgdG9vbENhbGxzOiBBcnJheTx7XHJcbiAgICAgIHRvb2xfbmFtZTogc3RyaW5nO1xyXG4gICAgICBwYXJhbWV0ZXJzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+O1xyXG4gICAgfT5cclxuICApOiBQcm9taXNlPGFueVtdPiB7XHJcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoXHJcbiAgICAgIHRvb2xDYWxscy5tYXAoY2FsbCA9PiBcclxuICAgICAgICB0aGlzLnRvb2xzW2NhbGwudG9vbF9uYW1lXS5mdW5jdGlvbihjYWxsLnBhcmFtZXRlcnMpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHVwZGF0ZU1lbW9yeShcclxuICAgIGNvbnRlbnQ6IHN0cmluZyxcclxuICAgIG1lbW9yeVR5cGU6IHN0cmluZyxcclxuICAgIG1ldGFkYXRhOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge31cclxuICApOiB2b2lkIHtcclxuICAgIHRoaXMubWVtb3J5LnB1c2goe1xyXG4gICAgICB0aW1lc3RhbXA6IG5ldyBEYXRlKCksXHJcbiAgICAgIGNvbnRlbnQsXHJcbiAgICAgIHR5cGU6IG1lbW9yeVR5cGUsXHJcbiAgICAgIG1ldGFkYXRhXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGFzeW5jIHByb2Nlc3NRdWVyeShxdWVyeTogc3RyaW5nKTogUHJvbWlzZTxzdHJpbmc+IHtcclxuICAgIC8vIFN0ZXAgMTogUmV0cmlldmUgcmVsZXZhbnQgaW5mb3JtYXRpb25cclxuICAgIGNvbnN0IHJlbGV2YW50SW5mbyA9IGF3YWl0IHRoaXMucmV0cmlldmVSZWxldmFudEluZm8ocXVlcnkpO1xyXG5cclxuICAgIC8vIFN0ZXAgMjogRGV0ZXJtaW5lIHJlcXVpcmVkIHRvb2xzXHJcbiAgICBjb25zdCBjb250ZXh0ID0ge1xyXG4gICAgICByZWxldmFudF9pbmZvOiByZWxldmFudEluZm8sXHJcbiAgICAgIHJlY2VudF9tZW1vcnk6IHRoaXMubWVtb3J5LnNsaWNlKC01KVxyXG4gICAgfTtcclxuICAgIGNvbnN0IHRvb2xDYWxscyA9IGF3YWl0IHRoaXMuZGV0ZXJtaW5lVG9vbE5lZWRzKHF1ZXJ5LCBjb250ZXh0KTtcclxuXHJcbiAgICAvLyBTdGVwIDM6IEV4ZWN1dGUgdG9vbHNcclxuICAgIGNvbnN0IHRvb2xSZXN1bHRzID0gYXdhaXQgdGhpcy5leGVjdXRlVG9vbHModG9vbENhbGxzKTtcclxuXHJcbiAgICAvLyBTdGVwIDQ6IEdlbmVyYXRlIHJlc3BvbnNlXHJcbiAgICBjb25zdCBSRVNQT05TRV9QUk9NUFQgPSBcXGBHZW5lcmF0ZSBhIHJlc3BvbnNlIHVzaW5nIGFsbCBhdmFpbGFibGUgaW5mb3JtYXRpb246XHJcbiAgICBcclxuICAgIFF1ZXJ5OiBcXCR7cXVlcnl9XHJcbiAgICBSZXRyaWV2ZWQgSW5mb3JtYXRpb246IFxcJHtKU09OLnN0cmluZ2lmeShyZWxldmFudEluZm8pfVxyXG4gICAgVG9vbCBSZXN1bHRzOiBcXCR7SlNPTi5zdHJpbmdpZnkodG9vbFJlc3VsdHMpfVxyXG4gICAgUmVjZW50IE1lbW9yeTogXFwke0pTT04uc3RyaW5naWZ5KHRoaXMubWVtb3J5LnNsaWNlKC01KSl9XHJcbiAgICBcclxuICAgIFN5bnRoZXNpemUgdGhpcyBpbmZvcm1hdGlvbiBpbnRvIGEgY29tcHJlaGVuc2l2ZSByZXNwb25zZS5cXGA7XHJcblxyXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBydW5MTE0oUkVTUE9OU0VfUFJPTVBUKTtcclxuXHJcbiAgICAvLyBTdGVwIDU6IFVwZGF0ZSBtZW1vcnlcclxuICAgIHRoaXMudXBkYXRlTWVtb3J5KHJlc3BvbnNlLCBcInJlc3BvbnNlXCIsIHsgcXVlcnkgfSk7XHJcblxyXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBjYWxjdWxhdGUocGFyYW1zOiBhbnkpOiBQcm9taXNlPG51bWJlcj4ge1xyXG4gICAgLy8gSW1wbGVtZW50YXRpb24gb2YgY2FsY3VsYXRvciB0b29sXHJcbiAgICByZXR1cm4gMDtcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgc2VhcmNoV2ViKHBhcmFtczogYW55KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIC8vIEltcGxlbWVudGF0aW9uIG9mIHdlYiBzZWFyY2ggdG9vbFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHF1ZXJ5RGF0YWJhc2UocGFyYW1zOiBhbnkpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgLy8gSW1wbGVtZW50YXRpb24gb2YgZGF0YWJhc2UgcXVlcnkgdG9vbFxyXG4gICAgcmV0dXJuIG51bGw7XHJcbiAgfVxyXG59XHJcblxyXG4vLyBFeGFtcGxlIHVzYWdlXHJcbmFzeW5jIGZ1bmN0aW9uIG1haW4oKSB7XHJcbiAgLy8gSW5pdGlhbGl6ZSBhdWdtZW50ZWQgTExNXHJcbiAgY29uc3QgbGxtID0gbmV3IEF1Z21lbnRlZExMTSgpO1xyXG5cclxuICAvLyBQcm9jZXNzIGEgY29tcGxleCBxdWVyeVxyXG4gIGNvbnN0IHF1ZXJ5ID0gXFxgV2hhdCB3YXMgdGhlIGltcGFjdCBvZiByZWNlbnQgaW50ZXJlc3QgcmF0ZSBjaGFuZ2VzIFxyXG4gIG9uIHRlY2ggY29tcGFueSBzdG9jayBwcmljZXM/IENhbGN1bGF0ZSB0aGUgYXZlcmFnZSBwZXJjZW50YWdlIGNoYW5nZSBcclxuICBhbmQgaWRlbnRpZnkgYW55IHNpZ25pZmljYW50IG91dGxpZXJzLlxcYDtcclxuXHJcbiAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBsbG0ucHJvY2Vzc1F1ZXJ5KHF1ZXJ5KTtcclxuICBjb25zb2xlLmxvZyhcIlJlc3BvbnNlOlwiLCByZXNwb25zZSk7XHJcbn1cclxuXHJcbm1haW4oKS5jYXRjaChjb25zb2xlLmVycm9yKTtgXHJcbn07XHJcbiJdLCJuYW1lcyI6WyJhdWdtZW50ZWRMbG0iLCJ0aXRsZSIsInRhZyIsImRlc2NyaXB0aW9uIiwiZXhwbGFuYXRpb24iLCJ1c2VDYXNlcyIsInB5dGhvbkNvZGUiLCJ0eXBlc2NyaXB0Q29kZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/recipes/data/augmented-llm.ts\n"));

/***/ })

});